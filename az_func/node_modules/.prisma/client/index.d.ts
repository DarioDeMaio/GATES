
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Dispositivo
 * 
 */
export type Dispositivo = $Result.DefaultSelection<Prisma.$DispositivoPayload>
/**
 * Model Acqua
 * 
 */
export type Acqua = $Result.DefaultSelection<Prisma.$AcquaPayload>
/**
 * Model MisurazioniAcqua
 * 
 */
export type MisurazioniAcqua = $Result.DefaultSelection<Prisma.$MisurazioniAcquaPayload>
/**
 * Model Aria
 * 
 */
export type Aria = $Result.DefaultSelection<Prisma.$AriaPayload>
/**
 * Model MisurazioniAria
 * 
 */
export type MisurazioniAria = $Result.DefaultSelection<Prisma.$MisurazioniAriaPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Dispositivos
 * const dispositivos = await prisma.dispositivo.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Dispositivos
   * const dispositivos = await prisma.dispositivo.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.dispositivo`: Exposes CRUD operations for the **Dispositivo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Dispositivos
    * const dispositivos = await prisma.dispositivo.findMany()
    * ```
    */
  get dispositivo(): Prisma.DispositivoDelegate<ExtArgs>;

  /**
   * `prisma.acqua`: Exposes CRUD operations for the **Acqua** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Acquas
    * const acquas = await prisma.acqua.findMany()
    * ```
    */
  get acqua(): Prisma.AcquaDelegate<ExtArgs>;

  /**
   * `prisma.misurazioniAcqua`: Exposes CRUD operations for the **MisurazioniAcqua** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MisurazioniAcquas
    * const misurazioniAcquas = await prisma.misurazioniAcqua.findMany()
    * ```
    */
  get misurazioniAcqua(): Prisma.MisurazioniAcquaDelegate<ExtArgs>;

  /**
   * `prisma.aria`: Exposes CRUD operations for the **Aria** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Arias
    * const arias = await prisma.aria.findMany()
    * ```
    */
  get aria(): Prisma.AriaDelegate<ExtArgs>;

  /**
   * `prisma.misurazioniAria`: Exposes CRUD operations for the **MisurazioniAria** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MisurazioniArias
    * const misurazioniArias = await prisma.misurazioniAria.findMany()
    * ```
    */
  get misurazioniAria(): Prisma.MisurazioniAriaDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.9.0
   * Query Engine version: 23fdc5965b1e05fc54e5f26ed3de66776b93de64
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Dispositivo: 'Dispositivo',
    Acqua: 'Acqua',
    MisurazioniAcqua: 'MisurazioniAcqua',
    Aria: 'Aria',
    MisurazioniAria: 'MisurazioniAria'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'dispositivo' | 'acqua' | 'misurazioniAcqua' | 'aria' | 'misurazioniAria'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      Dispositivo: {
        payload: Prisma.$DispositivoPayload<ExtArgs>
        fields: Prisma.DispositivoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DispositivoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DispositivoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DispositivoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DispositivoPayload>
          }
          findFirst: {
            args: Prisma.DispositivoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DispositivoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DispositivoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DispositivoPayload>
          }
          findMany: {
            args: Prisma.DispositivoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DispositivoPayload>[]
          }
          create: {
            args: Prisma.DispositivoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DispositivoPayload>
          }
          createMany: {
            args: Prisma.DispositivoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DispositivoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DispositivoPayload>
          }
          update: {
            args: Prisma.DispositivoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DispositivoPayload>
          }
          deleteMany: {
            args: Prisma.DispositivoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DispositivoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DispositivoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DispositivoPayload>
          }
          aggregate: {
            args: Prisma.DispositivoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDispositivo>
          }
          groupBy: {
            args: Prisma.DispositivoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DispositivoGroupByOutputType>[]
          }
          count: {
            args: Prisma.DispositivoCountArgs<ExtArgs>,
            result: $Utils.Optional<DispositivoCountAggregateOutputType> | number
          }
        }
      }
      Acqua: {
        payload: Prisma.$AcquaPayload<ExtArgs>
        fields: Prisma.AcquaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AcquaFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AcquaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AcquaFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AcquaPayload>
          }
          findFirst: {
            args: Prisma.AcquaFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AcquaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AcquaFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AcquaPayload>
          }
          findMany: {
            args: Prisma.AcquaFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AcquaPayload>[]
          }
          create: {
            args: Prisma.AcquaCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AcquaPayload>
          }
          createMany: {
            args: Prisma.AcquaCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AcquaDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AcquaPayload>
          }
          update: {
            args: Prisma.AcquaUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AcquaPayload>
          }
          deleteMany: {
            args: Prisma.AcquaDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AcquaUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AcquaUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AcquaPayload>
          }
          aggregate: {
            args: Prisma.AcquaAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAcqua>
          }
          groupBy: {
            args: Prisma.AcquaGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AcquaGroupByOutputType>[]
          }
          count: {
            args: Prisma.AcquaCountArgs<ExtArgs>,
            result: $Utils.Optional<AcquaCountAggregateOutputType> | number
          }
        }
      }
      MisurazioniAcqua: {
        payload: Prisma.$MisurazioniAcquaPayload<ExtArgs>
        fields: Prisma.MisurazioniAcquaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MisurazioniAcquaFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MisurazioniAcquaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MisurazioniAcquaFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MisurazioniAcquaPayload>
          }
          findFirst: {
            args: Prisma.MisurazioniAcquaFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MisurazioniAcquaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MisurazioniAcquaFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MisurazioniAcquaPayload>
          }
          findMany: {
            args: Prisma.MisurazioniAcquaFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MisurazioniAcquaPayload>[]
          }
          create: {
            args: Prisma.MisurazioniAcquaCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MisurazioniAcquaPayload>
          }
          createMany: {
            args: Prisma.MisurazioniAcquaCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MisurazioniAcquaDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MisurazioniAcquaPayload>
          }
          update: {
            args: Prisma.MisurazioniAcquaUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MisurazioniAcquaPayload>
          }
          deleteMany: {
            args: Prisma.MisurazioniAcquaDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MisurazioniAcquaUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MisurazioniAcquaUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MisurazioniAcquaPayload>
          }
          aggregate: {
            args: Prisma.MisurazioniAcquaAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMisurazioniAcqua>
          }
          groupBy: {
            args: Prisma.MisurazioniAcquaGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MisurazioniAcquaGroupByOutputType>[]
          }
          count: {
            args: Prisma.MisurazioniAcquaCountArgs<ExtArgs>,
            result: $Utils.Optional<MisurazioniAcquaCountAggregateOutputType> | number
          }
        }
      }
      Aria: {
        payload: Prisma.$AriaPayload<ExtArgs>
        fields: Prisma.AriaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AriaFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AriaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AriaFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AriaPayload>
          }
          findFirst: {
            args: Prisma.AriaFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AriaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AriaFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AriaPayload>
          }
          findMany: {
            args: Prisma.AriaFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AriaPayload>[]
          }
          create: {
            args: Prisma.AriaCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AriaPayload>
          }
          createMany: {
            args: Prisma.AriaCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AriaDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AriaPayload>
          }
          update: {
            args: Prisma.AriaUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AriaPayload>
          }
          deleteMany: {
            args: Prisma.AriaDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AriaUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AriaUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AriaPayload>
          }
          aggregate: {
            args: Prisma.AriaAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAria>
          }
          groupBy: {
            args: Prisma.AriaGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AriaGroupByOutputType>[]
          }
          count: {
            args: Prisma.AriaCountArgs<ExtArgs>,
            result: $Utils.Optional<AriaCountAggregateOutputType> | number
          }
        }
      }
      MisurazioniAria: {
        payload: Prisma.$MisurazioniAriaPayload<ExtArgs>
        fields: Prisma.MisurazioniAriaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MisurazioniAriaFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MisurazioniAriaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MisurazioniAriaFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MisurazioniAriaPayload>
          }
          findFirst: {
            args: Prisma.MisurazioniAriaFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MisurazioniAriaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MisurazioniAriaFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MisurazioniAriaPayload>
          }
          findMany: {
            args: Prisma.MisurazioniAriaFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MisurazioniAriaPayload>[]
          }
          create: {
            args: Prisma.MisurazioniAriaCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MisurazioniAriaPayload>
          }
          createMany: {
            args: Prisma.MisurazioniAriaCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MisurazioniAriaDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MisurazioniAriaPayload>
          }
          update: {
            args: Prisma.MisurazioniAriaUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MisurazioniAriaPayload>
          }
          deleteMany: {
            args: Prisma.MisurazioniAriaDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MisurazioniAriaUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MisurazioniAriaUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MisurazioniAriaPayload>
          }
          aggregate: {
            args: Prisma.MisurazioniAriaAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMisurazioniAria>
          }
          groupBy: {
            args: Prisma.MisurazioniAriaGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MisurazioniAriaGroupByOutputType>[]
          }
          count: {
            args: Prisma.MisurazioniAriaCountArgs<ExtArgs>,
            result: $Utils.Optional<MisurazioniAriaCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AcquaCountOutputType
   */

  export type AcquaCountOutputType = {
    misurazioniAcqua: number
  }

  export type AcquaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    misurazioniAcqua?: boolean | AcquaCountOutputTypeCountMisurazioniAcquaArgs
  }

  // Custom InputTypes

  /**
   * AcquaCountOutputType without action
   */
  export type AcquaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcquaCountOutputType
     */
    select?: AcquaCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * AcquaCountOutputType without action
   */
  export type AcquaCountOutputTypeCountMisurazioniAcquaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MisurazioniAcquaWhereInput
  }



  /**
   * Count Type AriaCountOutputType
   */

  export type AriaCountOutputType = {
    misurazioneAria: number
  }

  export type AriaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    misurazioneAria?: boolean | AriaCountOutputTypeCountMisurazioneAriaArgs
  }

  // Custom InputTypes

  /**
   * AriaCountOutputType without action
   */
  export type AriaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AriaCountOutputType
     */
    select?: AriaCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * AriaCountOutputType without action
   */
  export type AriaCountOutputTypeCountMisurazioneAriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MisurazioniAriaWhereInput
  }



  /**
   * Models
   */

  /**
   * Model Dispositivo
   */

  export type AggregateDispositivo = {
    _count: DispositivoCountAggregateOutputType | null
    _avg: DispositivoAvgAggregateOutputType | null
    _sum: DispositivoSumAggregateOutputType | null
    _min: DispositivoMinAggregateOutputType | null
    _max: DispositivoMaxAggregateOutputType | null
  }

  export type DispositivoAvgAggregateOutputType = {
    id: number | null
  }

  export type DispositivoSumAggregateOutputType = {
    id: number | null
  }

  export type DispositivoMinAggregateOutputType = {
    id: number | null
    connectionString: string | null
    matricola: string | null
  }

  export type DispositivoMaxAggregateOutputType = {
    id: number | null
    connectionString: string | null
    matricola: string | null
  }

  export type DispositivoCountAggregateOutputType = {
    id: number
    connectionString: number
    matricola: number
    _all: number
  }


  export type DispositivoAvgAggregateInputType = {
    id?: true
  }

  export type DispositivoSumAggregateInputType = {
    id?: true
  }

  export type DispositivoMinAggregateInputType = {
    id?: true
    connectionString?: true
    matricola?: true
  }

  export type DispositivoMaxAggregateInputType = {
    id?: true
    connectionString?: true
    matricola?: true
  }

  export type DispositivoCountAggregateInputType = {
    id?: true
    connectionString?: true
    matricola?: true
    _all?: true
  }

  export type DispositivoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dispositivo to aggregate.
     */
    where?: DispositivoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dispositivos to fetch.
     */
    orderBy?: DispositivoOrderByWithRelationInput | DispositivoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DispositivoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dispositivos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dispositivos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Dispositivos
    **/
    _count?: true | DispositivoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DispositivoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DispositivoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DispositivoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DispositivoMaxAggregateInputType
  }

  export type GetDispositivoAggregateType<T extends DispositivoAggregateArgs> = {
        [P in keyof T & keyof AggregateDispositivo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDispositivo[P]>
      : GetScalarType<T[P], AggregateDispositivo[P]>
  }




  export type DispositivoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DispositivoWhereInput
    orderBy?: DispositivoOrderByWithAggregationInput | DispositivoOrderByWithAggregationInput[]
    by: DispositivoScalarFieldEnum[] | DispositivoScalarFieldEnum
    having?: DispositivoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DispositivoCountAggregateInputType | true
    _avg?: DispositivoAvgAggregateInputType
    _sum?: DispositivoSumAggregateInputType
    _min?: DispositivoMinAggregateInputType
    _max?: DispositivoMaxAggregateInputType
  }

  export type DispositivoGroupByOutputType = {
    id: number
    connectionString: string
    matricola: string
    _count: DispositivoCountAggregateOutputType | null
    _avg: DispositivoAvgAggregateOutputType | null
    _sum: DispositivoSumAggregateOutputType | null
    _min: DispositivoMinAggregateOutputType | null
    _max: DispositivoMaxAggregateOutputType | null
  }

  type GetDispositivoGroupByPayload<T extends DispositivoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DispositivoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DispositivoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DispositivoGroupByOutputType[P]>
            : GetScalarType<T[P], DispositivoGroupByOutputType[P]>
        }
      >
    >


  export type DispositivoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    connectionString?: boolean
    matricola?: boolean
    water?: boolean | Dispositivo$waterArgs<ExtArgs>
    aria?: boolean | Dispositivo$ariaArgs<ExtArgs>
  }, ExtArgs["result"]["dispositivo"]>

  export type DispositivoSelectScalar = {
    id?: boolean
    connectionString?: boolean
    matricola?: boolean
  }

  export type DispositivoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    water?: boolean | Dispositivo$waterArgs<ExtArgs>
    aria?: boolean | Dispositivo$ariaArgs<ExtArgs>
  }


  export type $DispositivoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Dispositivo"
    objects: {
      water: Prisma.$AcquaPayload<ExtArgs> | null
      aria: Prisma.$AriaPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      connectionString: string
      matricola: string
    }, ExtArgs["result"]["dispositivo"]>
    composites: {}
  }


  type DispositivoGetPayload<S extends boolean | null | undefined | DispositivoDefaultArgs> = $Result.GetResult<Prisma.$DispositivoPayload, S>

  type DispositivoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DispositivoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DispositivoCountAggregateInputType | true
    }

  export interface DispositivoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Dispositivo'], meta: { name: 'Dispositivo' } }
    /**
     * Find zero or one Dispositivo that matches the filter.
     * @param {DispositivoFindUniqueArgs} args - Arguments to find a Dispositivo
     * @example
     * // Get one Dispositivo
     * const dispositivo = await prisma.dispositivo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DispositivoFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DispositivoFindUniqueArgs<ExtArgs>>
    ): Prisma__DispositivoClient<$Result.GetResult<Prisma.$DispositivoPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Dispositivo that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DispositivoFindUniqueOrThrowArgs} args - Arguments to find a Dispositivo
     * @example
     * // Get one Dispositivo
     * const dispositivo = await prisma.dispositivo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DispositivoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DispositivoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DispositivoClient<$Result.GetResult<Prisma.$DispositivoPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Dispositivo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispositivoFindFirstArgs} args - Arguments to find a Dispositivo
     * @example
     * // Get one Dispositivo
     * const dispositivo = await prisma.dispositivo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DispositivoFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DispositivoFindFirstArgs<ExtArgs>>
    ): Prisma__DispositivoClient<$Result.GetResult<Prisma.$DispositivoPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Dispositivo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispositivoFindFirstOrThrowArgs} args - Arguments to find a Dispositivo
     * @example
     * // Get one Dispositivo
     * const dispositivo = await prisma.dispositivo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DispositivoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DispositivoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DispositivoClient<$Result.GetResult<Prisma.$DispositivoPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Dispositivos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispositivoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Dispositivos
     * const dispositivos = await prisma.dispositivo.findMany()
     * 
     * // Get first 10 Dispositivos
     * const dispositivos = await prisma.dispositivo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dispositivoWithIdOnly = await prisma.dispositivo.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DispositivoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DispositivoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DispositivoPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Dispositivo.
     * @param {DispositivoCreateArgs} args - Arguments to create a Dispositivo.
     * @example
     * // Create one Dispositivo
     * const Dispositivo = await prisma.dispositivo.create({
     *   data: {
     *     // ... data to create a Dispositivo
     *   }
     * })
     * 
    **/
    create<T extends DispositivoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DispositivoCreateArgs<ExtArgs>>
    ): Prisma__DispositivoClient<$Result.GetResult<Prisma.$DispositivoPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Dispositivos.
     *     @param {DispositivoCreateManyArgs} args - Arguments to create many Dispositivos.
     *     @example
     *     // Create many Dispositivos
     *     const dispositivo = await prisma.dispositivo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DispositivoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DispositivoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Dispositivo.
     * @param {DispositivoDeleteArgs} args - Arguments to delete one Dispositivo.
     * @example
     * // Delete one Dispositivo
     * const Dispositivo = await prisma.dispositivo.delete({
     *   where: {
     *     // ... filter to delete one Dispositivo
     *   }
     * })
     * 
    **/
    delete<T extends DispositivoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DispositivoDeleteArgs<ExtArgs>>
    ): Prisma__DispositivoClient<$Result.GetResult<Prisma.$DispositivoPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Dispositivo.
     * @param {DispositivoUpdateArgs} args - Arguments to update one Dispositivo.
     * @example
     * // Update one Dispositivo
     * const dispositivo = await prisma.dispositivo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DispositivoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DispositivoUpdateArgs<ExtArgs>>
    ): Prisma__DispositivoClient<$Result.GetResult<Prisma.$DispositivoPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Dispositivos.
     * @param {DispositivoDeleteManyArgs} args - Arguments to filter Dispositivos to delete.
     * @example
     * // Delete a few Dispositivos
     * const { count } = await prisma.dispositivo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DispositivoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DispositivoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dispositivos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispositivoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Dispositivos
     * const dispositivo = await prisma.dispositivo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DispositivoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DispositivoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Dispositivo.
     * @param {DispositivoUpsertArgs} args - Arguments to update or create a Dispositivo.
     * @example
     * // Update or create a Dispositivo
     * const dispositivo = await prisma.dispositivo.upsert({
     *   create: {
     *     // ... data to create a Dispositivo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dispositivo we want to update
     *   }
     * })
    **/
    upsert<T extends DispositivoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DispositivoUpsertArgs<ExtArgs>>
    ): Prisma__DispositivoClient<$Result.GetResult<Prisma.$DispositivoPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Dispositivos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispositivoCountArgs} args - Arguments to filter Dispositivos to count.
     * @example
     * // Count the number of Dispositivos
     * const count = await prisma.dispositivo.count({
     *   where: {
     *     // ... the filter for the Dispositivos we want to count
     *   }
     * })
    **/
    count<T extends DispositivoCountArgs>(
      args?: Subset<T, DispositivoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DispositivoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dispositivo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispositivoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DispositivoAggregateArgs>(args: Subset<T, DispositivoAggregateArgs>): Prisma.PrismaPromise<GetDispositivoAggregateType<T>>

    /**
     * Group by Dispositivo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispositivoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DispositivoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DispositivoGroupByArgs['orderBy'] }
        : { orderBy?: DispositivoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DispositivoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDispositivoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Dispositivo model
   */
  readonly fields: DispositivoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Dispositivo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DispositivoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    water<T extends Dispositivo$waterArgs<ExtArgs> = {}>(args?: Subset<T, Dispositivo$waterArgs<ExtArgs>>): Prisma__AcquaClient<$Result.GetResult<Prisma.$AcquaPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    aria<T extends Dispositivo$ariaArgs<ExtArgs> = {}>(args?: Subset<T, Dispositivo$ariaArgs<ExtArgs>>): Prisma__AriaClient<$Result.GetResult<Prisma.$AriaPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Dispositivo model
   */ 
  interface DispositivoFieldRefs {
    readonly id: FieldRef<"Dispositivo", 'Int'>
    readonly connectionString: FieldRef<"Dispositivo", 'String'>
    readonly matricola: FieldRef<"Dispositivo", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Dispositivo findUnique
   */
  export type DispositivoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispositivo
     */
    select?: DispositivoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DispositivoInclude<ExtArgs> | null
    /**
     * Filter, which Dispositivo to fetch.
     */
    where: DispositivoWhereUniqueInput
  }


  /**
   * Dispositivo findUniqueOrThrow
   */
  export type DispositivoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispositivo
     */
    select?: DispositivoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DispositivoInclude<ExtArgs> | null
    /**
     * Filter, which Dispositivo to fetch.
     */
    where: DispositivoWhereUniqueInput
  }


  /**
   * Dispositivo findFirst
   */
  export type DispositivoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispositivo
     */
    select?: DispositivoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DispositivoInclude<ExtArgs> | null
    /**
     * Filter, which Dispositivo to fetch.
     */
    where?: DispositivoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dispositivos to fetch.
     */
    orderBy?: DispositivoOrderByWithRelationInput | DispositivoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dispositivos.
     */
    cursor?: DispositivoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dispositivos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dispositivos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dispositivos.
     */
    distinct?: DispositivoScalarFieldEnum | DispositivoScalarFieldEnum[]
  }


  /**
   * Dispositivo findFirstOrThrow
   */
  export type DispositivoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispositivo
     */
    select?: DispositivoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DispositivoInclude<ExtArgs> | null
    /**
     * Filter, which Dispositivo to fetch.
     */
    where?: DispositivoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dispositivos to fetch.
     */
    orderBy?: DispositivoOrderByWithRelationInput | DispositivoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dispositivos.
     */
    cursor?: DispositivoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dispositivos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dispositivos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dispositivos.
     */
    distinct?: DispositivoScalarFieldEnum | DispositivoScalarFieldEnum[]
  }


  /**
   * Dispositivo findMany
   */
  export type DispositivoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispositivo
     */
    select?: DispositivoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DispositivoInclude<ExtArgs> | null
    /**
     * Filter, which Dispositivos to fetch.
     */
    where?: DispositivoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dispositivos to fetch.
     */
    orderBy?: DispositivoOrderByWithRelationInput | DispositivoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Dispositivos.
     */
    cursor?: DispositivoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dispositivos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dispositivos.
     */
    skip?: number
    distinct?: DispositivoScalarFieldEnum | DispositivoScalarFieldEnum[]
  }


  /**
   * Dispositivo create
   */
  export type DispositivoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispositivo
     */
    select?: DispositivoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DispositivoInclude<ExtArgs> | null
    /**
     * The data needed to create a Dispositivo.
     */
    data: XOR<DispositivoCreateInput, DispositivoUncheckedCreateInput>
  }


  /**
   * Dispositivo createMany
   */
  export type DispositivoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Dispositivos.
     */
    data: DispositivoCreateManyInput | DispositivoCreateManyInput[]
  }


  /**
   * Dispositivo update
   */
  export type DispositivoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispositivo
     */
    select?: DispositivoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DispositivoInclude<ExtArgs> | null
    /**
     * The data needed to update a Dispositivo.
     */
    data: XOR<DispositivoUpdateInput, DispositivoUncheckedUpdateInput>
    /**
     * Choose, which Dispositivo to update.
     */
    where: DispositivoWhereUniqueInput
  }


  /**
   * Dispositivo updateMany
   */
  export type DispositivoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Dispositivos.
     */
    data: XOR<DispositivoUpdateManyMutationInput, DispositivoUncheckedUpdateManyInput>
    /**
     * Filter which Dispositivos to update
     */
    where?: DispositivoWhereInput
  }


  /**
   * Dispositivo upsert
   */
  export type DispositivoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispositivo
     */
    select?: DispositivoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DispositivoInclude<ExtArgs> | null
    /**
     * The filter to search for the Dispositivo to update in case it exists.
     */
    where: DispositivoWhereUniqueInput
    /**
     * In case the Dispositivo found by the `where` argument doesn't exist, create a new Dispositivo with this data.
     */
    create: XOR<DispositivoCreateInput, DispositivoUncheckedCreateInput>
    /**
     * In case the Dispositivo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DispositivoUpdateInput, DispositivoUncheckedUpdateInput>
  }


  /**
   * Dispositivo delete
   */
  export type DispositivoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispositivo
     */
    select?: DispositivoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DispositivoInclude<ExtArgs> | null
    /**
     * Filter which Dispositivo to delete.
     */
    where: DispositivoWhereUniqueInput
  }


  /**
   * Dispositivo deleteMany
   */
  export type DispositivoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dispositivos to delete
     */
    where?: DispositivoWhereInput
  }


  /**
   * Dispositivo.water
   */
  export type Dispositivo$waterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acqua
     */
    select?: AcquaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AcquaInclude<ExtArgs> | null
    where?: AcquaWhereInput
  }


  /**
   * Dispositivo.aria
   */
  export type Dispositivo$ariaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aria
     */
    select?: AriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AriaInclude<ExtArgs> | null
    where?: AriaWhereInput
  }


  /**
   * Dispositivo without action
   */
  export type DispositivoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispositivo
     */
    select?: DispositivoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DispositivoInclude<ExtArgs> | null
  }



  /**
   * Model Acqua
   */

  export type AggregateAcqua = {
    _count: AcquaCountAggregateOutputType | null
    _avg: AcquaAvgAggregateOutputType | null
    _sum: AcquaSumAggregateOutputType | null
    _min: AcquaMinAggregateOutputType | null
    _max: AcquaMaxAggregateOutputType | null
  }

  export type AcquaAvgAggregateOutputType = {
    idDispositivo: number | null
  }

  export type AcquaSumAggregateOutputType = {
    idDispositivo: number | null
  }

  export type AcquaMinAggregateOutputType = {
    idDispositivo: number | null
  }

  export type AcquaMaxAggregateOutputType = {
    idDispositivo: number | null
  }

  export type AcquaCountAggregateOutputType = {
    idDispositivo: number
    _all: number
  }


  export type AcquaAvgAggregateInputType = {
    idDispositivo?: true
  }

  export type AcquaSumAggregateInputType = {
    idDispositivo?: true
  }

  export type AcquaMinAggregateInputType = {
    idDispositivo?: true
  }

  export type AcquaMaxAggregateInputType = {
    idDispositivo?: true
  }

  export type AcquaCountAggregateInputType = {
    idDispositivo?: true
    _all?: true
  }

  export type AcquaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Acqua to aggregate.
     */
    where?: AcquaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Acquas to fetch.
     */
    orderBy?: AcquaOrderByWithRelationInput | AcquaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AcquaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Acquas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Acquas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Acquas
    **/
    _count?: true | AcquaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AcquaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AcquaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AcquaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AcquaMaxAggregateInputType
  }

  export type GetAcquaAggregateType<T extends AcquaAggregateArgs> = {
        [P in keyof T & keyof AggregateAcqua]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAcqua[P]>
      : GetScalarType<T[P], AggregateAcqua[P]>
  }




  export type AcquaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcquaWhereInput
    orderBy?: AcquaOrderByWithAggregationInput | AcquaOrderByWithAggregationInput[]
    by: AcquaScalarFieldEnum[] | AcquaScalarFieldEnum
    having?: AcquaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AcquaCountAggregateInputType | true
    _avg?: AcquaAvgAggregateInputType
    _sum?: AcquaSumAggregateInputType
    _min?: AcquaMinAggregateInputType
    _max?: AcquaMaxAggregateInputType
  }

  export type AcquaGroupByOutputType = {
    idDispositivo: number
    _count: AcquaCountAggregateOutputType | null
    _avg: AcquaAvgAggregateOutputType | null
    _sum: AcquaSumAggregateOutputType | null
    _min: AcquaMinAggregateOutputType | null
    _max: AcquaMaxAggregateOutputType | null
  }

  type GetAcquaGroupByPayload<T extends AcquaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AcquaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AcquaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AcquaGroupByOutputType[P]>
            : GetScalarType<T[P], AcquaGroupByOutputType[P]>
        }
      >
    >


  export type AcquaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idDispositivo?: boolean
    device?: boolean | DispositivoDefaultArgs<ExtArgs>
    misurazioniAcqua?: boolean | Acqua$misurazioniAcquaArgs<ExtArgs>
    _count?: boolean | AcquaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["acqua"]>

  export type AcquaSelectScalar = {
    idDispositivo?: boolean
  }

  export type AcquaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | DispositivoDefaultArgs<ExtArgs>
    misurazioniAcqua?: boolean | Acqua$misurazioniAcquaArgs<ExtArgs>
    _count?: boolean | AcquaCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $AcquaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Acqua"
    objects: {
      device: Prisma.$DispositivoPayload<ExtArgs>
      misurazioniAcqua: Prisma.$MisurazioniAcquaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idDispositivo: number
    }, ExtArgs["result"]["acqua"]>
    composites: {}
  }


  type AcquaGetPayload<S extends boolean | null | undefined | AcquaDefaultArgs> = $Result.GetResult<Prisma.$AcquaPayload, S>

  type AcquaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AcquaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AcquaCountAggregateInputType | true
    }

  export interface AcquaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Acqua'], meta: { name: 'Acqua' } }
    /**
     * Find zero or one Acqua that matches the filter.
     * @param {AcquaFindUniqueArgs} args - Arguments to find a Acqua
     * @example
     * // Get one Acqua
     * const acqua = await prisma.acqua.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AcquaFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AcquaFindUniqueArgs<ExtArgs>>
    ): Prisma__AcquaClient<$Result.GetResult<Prisma.$AcquaPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Acqua that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AcquaFindUniqueOrThrowArgs} args - Arguments to find a Acqua
     * @example
     * // Get one Acqua
     * const acqua = await prisma.acqua.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AcquaFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AcquaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AcquaClient<$Result.GetResult<Prisma.$AcquaPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Acqua that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcquaFindFirstArgs} args - Arguments to find a Acqua
     * @example
     * // Get one Acqua
     * const acqua = await prisma.acqua.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AcquaFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AcquaFindFirstArgs<ExtArgs>>
    ): Prisma__AcquaClient<$Result.GetResult<Prisma.$AcquaPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Acqua that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcquaFindFirstOrThrowArgs} args - Arguments to find a Acqua
     * @example
     * // Get one Acqua
     * const acqua = await prisma.acqua.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AcquaFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AcquaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AcquaClient<$Result.GetResult<Prisma.$AcquaPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Acquas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcquaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Acquas
     * const acquas = await prisma.acqua.findMany()
     * 
     * // Get first 10 Acquas
     * const acquas = await prisma.acqua.findMany({ take: 10 })
     * 
     * // Only select the `idDispositivo`
     * const acquaWithIdDispositivoOnly = await prisma.acqua.findMany({ select: { idDispositivo: true } })
     * 
    **/
    findMany<T extends AcquaFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AcquaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcquaPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Acqua.
     * @param {AcquaCreateArgs} args - Arguments to create a Acqua.
     * @example
     * // Create one Acqua
     * const Acqua = await prisma.acqua.create({
     *   data: {
     *     // ... data to create a Acqua
     *   }
     * })
     * 
    **/
    create<T extends AcquaCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AcquaCreateArgs<ExtArgs>>
    ): Prisma__AcquaClient<$Result.GetResult<Prisma.$AcquaPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Acquas.
     *     @param {AcquaCreateManyArgs} args - Arguments to create many Acquas.
     *     @example
     *     // Create many Acquas
     *     const acqua = await prisma.acqua.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AcquaCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AcquaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Acqua.
     * @param {AcquaDeleteArgs} args - Arguments to delete one Acqua.
     * @example
     * // Delete one Acqua
     * const Acqua = await prisma.acqua.delete({
     *   where: {
     *     // ... filter to delete one Acqua
     *   }
     * })
     * 
    **/
    delete<T extends AcquaDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AcquaDeleteArgs<ExtArgs>>
    ): Prisma__AcquaClient<$Result.GetResult<Prisma.$AcquaPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Acqua.
     * @param {AcquaUpdateArgs} args - Arguments to update one Acqua.
     * @example
     * // Update one Acqua
     * const acqua = await prisma.acqua.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AcquaUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AcquaUpdateArgs<ExtArgs>>
    ): Prisma__AcquaClient<$Result.GetResult<Prisma.$AcquaPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Acquas.
     * @param {AcquaDeleteManyArgs} args - Arguments to filter Acquas to delete.
     * @example
     * // Delete a few Acquas
     * const { count } = await prisma.acqua.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AcquaDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AcquaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Acquas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcquaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Acquas
     * const acqua = await prisma.acqua.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AcquaUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AcquaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Acqua.
     * @param {AcquaUpsertArgs} args - Arguments to update or create a Acqua.
     * @example
     * // Update or create a Acqua
     * const acqua = await prisma.acqua.upsert({
     *   create: {
     *     // ... data to create a Acqua
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Acqua we want to update
     *   }
     * })
    **/
    upsert<T extends AcquaUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AcquaUpsertArgs<ExtArgs>>
    ): Prisma__AcquaClient<$Result.GetResult<Prisma.$AcquaPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Acquas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcquaCountArgs} args - Arguments to filter Acquas to count.
     * @example
     * // Count the number of Acquas
     * const count = await prisma.acqua.count({
     *   where: {
     *     // ... the filter for the Acquas we want to count
     *   }
     * })
    **/
    count<T extends AcquaCountArgs>(
      args?: Subset<T, AcquaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AcquaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Acqua.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcquaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AcquaAggregateArgs>(args: Subset<T, AcquaAggregateArgs>): Prisma.PrismaPromise<GetAcquaAggregateType<T>>

    /**
     * Group by Acqua.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcquaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AcquaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AcquaGroupByArgs['orderBy'] }
        : { orderBy?: AcquaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AcquaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAcquaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Acqua model
   */
  readonly fields: AcquaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Acqua.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AcquaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    device<T extends DispositivoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DispositivoDefaultArgs<ExtArgs>>): Prisma__DispositivoClient<$Result.GetResult<Prisma.$DispositivoPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    misurazioniAcqua<T extends Acqua$misurazioniAcquaArgs<ExtArgs> = {}>(args?: Subset<T, Acqua$misurazioniAcquaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MisurazioniAcquaPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Acqua model
   */ 
  interface AcquaFieldRefs {
    readonly idDispositivo: FieldRef<"Acqua", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Acqua findUnique
   */
  export type AcquaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acqua
     */
    select?: AcquaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AcquaInclude<ExtArgs> | null
    /**
     * Filter, which Acqua to fetch.
     */
    where: AcquaWhereUniqueInput
  }


  /**
   * Acqua findUniqueOrThrow
   */
  export type AcquaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acqua
     */
    select?: AcquaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AcquaInclude<ExtArgs> | null
    /**
     * Filter, which Acqua to fetch.
     */
    where: AcquaWhereUniqueInput
  }


  /**
   * Acqua findFirst
   */
  export type AcquaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acqua
     */
    select?: AcquaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AcquaInclude<ExtArgs> | null
    /**
     * Filter, which Acqua to fetch.
     */
    where?: AcquaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Acquas to fetch.
     */
    orderBy?: AcquaOrderByWithRelationInput | AcquaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Acquas.
     */
    cursor?: AcquaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Acquas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Acquas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Acquas.
     */
    distinct?: AcquaScalarFieldEnum | AcquaScalarFieldEnum[]
  }


  /**
   * Acqua findFirstOrThrow
   */
  export type AcquaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acqua
     */
    select?: AcquaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AcquaInclude<ExtArgs> | null
    /**
     * Filter, which Acqua to fetch.
     */
    where?: AcquaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Acquas to fetch.
     */
    orderBy?: AcquaOrderByWithRelationInput | AcquaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Acquas.
     */
    cursor?: AcquaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Acquas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Acquas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Acquas.
     */
    distinct?: AcquaScalarFieldEnum | AcquaScalarFieldEnum[]
  }


  /**
   * Acqua findMany
   */
  export type AcquaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acqua
     */
    select?: AcquaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AcquaInclude<ExtArgs> | null
    /**
     * Filter, which Acquas to fetch.
     */
    where?: AcquaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Acquas to fetch.
     */
    orderBy?: AcquaOrderByWithRelationInput | AcquaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Acquas.
     */
    cursor?: AcquaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Acquas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Acquas.
     */
    skip?: number
    distinct?: AcquaScalarFieldEnum | AcquaScalarFieldEnum[]
  }


  /**
   * Acqua create
   */
  export type AcquaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acqua
     */
    select?: AcquaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AcquaInclude<ExtArgs> | null
    /**
     * The data needed to create a Acqua.
     */
    data: XOR<AcquaCreateInput, AcquaUncheckedCreateInput>
  }


  /**
   * Acqua createMany
   */
  export type AcquaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Acquas.
     */
    data: AcquaCreateManyInput | AcquaCreateManyInput[]
  }


  /**
   * Acqua update
   */
  export type AcquaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acqua
     */
    select?: AcquaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AcquaInclude<ExtArgs> | null
    /**
     * The data needed to update a Acqua.
     */
    data: XOR<AcquaUpdateInput, AcquaUncheckedUpdateInput>
    /**
     * Choose, which Acqua to update.
     */
    where: AcquaWhereUniqueInput
  }


  /**
   * Acqua updateMany
   */
  export type AcquaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Acquas.
     */
    data: XOR<AcquaUpdateManyMutationInput, AcquaUncheckedUpdateManyInput>
    /**
     * Filter which Acquas to update
     */
    where?: AcquaWhereInput
  }


  /**
   * Acqua upsert
   */
  export type AcquaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acqua
     */
    select?: AcquaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AcquaInclude<ExtArgs> | null
    /**
     * The filter to search for the Acqua to update in case it exists.
     */
    where: AcquaWhereUniqueInput
    /**
     * In case the Acqua found by the `where` argument doesn't exist, create a new Acqua with this data.
     */
    create: XOR<AcquaCreateInput, AcquaUncheckedCreateInput>
    /**
     * In case the Acqua was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AcquaUpdateInput, AcquaUncheckedUpdateInput>
  }


  /**
   * Acqua delete
   */
  export type AcquaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acqua
     */
    select?: AcquaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AcquaInclude<ExtArgs> | null
    /**
     * Filter which Acqua to delete.
     */
    where: AcquaWhereUniqueInput
  }


  /**
   * Acqua deleteMany
   */
  export type AcquaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Acquas to delete
     */
    where?: AcquaWhereInput
  }


  /**
   * Acqua.misurazioniAcqua
   */
  export type Acqua$misurazioniAcquaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MisurazioniAcqua
     */
    select?: MisurazioniAcquaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MisurazioniAcquaInclude<ExtArgs> | null
    where?: MisurazioniAcquaWhereInput
    orderBy?: MisurazioniAcquaOrderByWithRelationInput | MisurazioniAcquaOrderByWithRelationInput[]
    cursor?: MisurazioniAcquaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MisurazioniAcquaScalarFieldEnum | MisurazioniAcquaScalarFieldEnum[]
  }


  /**
   * Acqua without action
   */
  export type AcquaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acqua
     */
    select?: AcquaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AcquaInclude<ExtArgs> | null
  }



  /**
   * Model MisurazioniAcqua
   */

  export type AggregateMisurazioniAcqua = {
    _count: MisurazioniAcquaCountAggregateOutputType | null
    _avg: MisurazioniAcquaAvgAggregateOutputType | null
    _sum: MisurazioniAcquaSumAggregateOutputType | null
    _min: MisurazioniAcquaMinAggregateOutputType | null
    _max: MisurazioniAcquaMaxAggregateOutputType | null
  }

  export type MisurazioniAcquaAvgAggregateOutputType = {
    id: number | null
    pH: number | null
    metalli: number | null
    dispId: number | null
  }

  export type MisurazioniAcquaSumAggregateOutputType = {
    id: number | null
    pH: number | null
    metalli: number | null
    dispId: number | null
  }

  export type MisurazioniAcquaMinAggregateOutputType = {
    id: number | null
    pH: number | null
    metalli: number | null
    data: Date | null
    dispId: number | null
  }

  export type MisurazioniAcquaMaxAggregateOutputType = {
    id: number | null
    pH: number | null
    metalli: number | null
    data: Date | null
    dispId: number | null
  }

  export type MisurazioniAcquaCountAggregateOutputType = {
    id: number
    pH: number
    metalli: number
    data: number
    dispId: number
    _all: number
  }


  export type MisurazioniAcquaAvgAggregateInputType = {
    id?: true
    pH?: true
    metalli?: true
    dispId?: true
  }

  export type MisurazioniAcquaSumAggregateInputType = {
    id?: true
    pH?: true
    metalli?: true
    dispId?: true
  }

  export type MisurazioniAcquaMinAggregateInputType = {
    id?: true
    pH?: true
    metalli?: true
    data?: true
    dispId?: true
  }

  export type MisurazioniAcquaMaxAggregateInputType = {
    id?: true
    pH?: true
    metalli?: true
    data?: true
    dispId?: true
  }

  export type MisurazioniAcquaCountAggregateInputType = {
    id?: true
    pH?: true
    metalli?: true
    data?: true
    dispId?: true
    _all?: true
  }

  export type MisurazioniAcquaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MisurazioniAcqua to aggregate.
     */
    where?: MisurazioniAcquaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MisurazioniAcquas to fetch.
     */
    orderBy?: MisurazioniAcquaOrderByWithRelationInput | MisurazioniAcquaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MisurazioniAcquaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MisurazioniAcquas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MisurazioniAcquas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MisurazioniAcquas
    **/
    _count?: true | MisurazioniAcquaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MisurazioniAcquaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MisurazioniAcquaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MisurazioniAcquaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MisurazioniAcquaMaxAggregateInputType
  }

  export type GetMisurazioniAcquaAggregateType<T extends MisurazioniAcquaAggregateArgs> = {
        [P in keyof T & keyof AggregateMisurazioniAcqua]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMisurazioniAcqua[P]>
      : GetScalarType<T[P], AggregateMisurazioniAcqua[P]>
  }




  export type MisurazioniAcquaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MisurazioniAcquaWhereInput
    orderBy?: MisurazioniAcquaOrderByWithAggregationInput | MisurazioniAcquaOrderByWithAggregationInput[]
    by: MisurazioniAcquaScalarFieldEnum[] | MisurazioniAcquaScalarFieldEnum
    having?: MisurazioniAcquaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MisurazioniAcquaCountAggregateInputType | true
    _avg?: MisurazioniAcquaAvgAggregateInputType
    _sum?: MisurazioniAcquaSumAggregateInputType
    _min?: MisurazioniAcquaMinAggregateInputType
    _max?: MisurazioniAcquaMaxAggregateInputType
  }

  export type MisurazioniAcquaGroupByOutputType = {
    id: number
    pH: number
    metalli: number
    data: Date
    dispId: number
    _count: MisurazioniAcquaCountAggregateOutputType | null
    _avg: MisurazioniAcquaAvgAggregateOutputType | null
    _sum: MisurazioniAcquaSumAggregateOutputType | null
    _min: MisurazioniAcquaMinAggregateOutputType | null
    _max: MisurazioniAcquaMaxAggregateOutputType | null
  }

  type GetMisurazioniAcquaGroupByPayload<T extends MisurazioniAcquaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MisurazioniAcquaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MisurazioniAcquaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MisurazioniAcquaGroupByOutputType[P]>
            : GetScalarType<T[P], MisurazioniAcquaGroupByOutputType[P]>
        }
      >
    >


  export type MisurazioniAcquaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pH?: boolean
    metalli?: boolean
    data?: boolean
    dispId?: boolean
    dispositivo?: boolean | AcquaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["misurazioniAcqua"]>

  export type MisurazioniAcquaSelectScalar = {
    id?: boolean
    pH?: boolean
    metalli?: boolean
    data?: boolean
    dispId?: boolean
  }

  export type MisurazioniAcquaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dispositivo?: boolean | AcquaDefaultArgs<ExtArgs>
  }


  export type $MisurazioniAcquaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MisurazioniAcqua"
    objects: {
      dispositivo: Prisma.$AcquaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pH: number
      metalli: number
      data: Date
      dispId: number
    }, ExtArgs["result"]["misurazioniAcqua"]>
    composites: {}
  }


  type MisurazioniAcquaGetPayload<S extends boolean | null | undefined | MisurazioniAcquaDefaultArgs> = $Result.GetResult<Prisma.$MisurazioniAcquaPayload, S>

  type MisurazioniAcquaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MisurazioniAcquaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MisurazioniAcquaCountAggregateInputType | true
    }

  export interface MisurazioniAcquaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MisurazioniAcqua'], meta: { name: 'MisurazioniAcqua' } }
    /**
     * Find zero or one MisurazioniAcqua that matches the filter.
     * @param {MisurazioniAcquaFindUniqueArgs} args - Arguments to find a MisurazioniAcqua
     * @example
     * // Get one MisurazioniAcqua
     * const misurazioniAcqua = await prisma.misurazioniAcqua.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MisurazioniAcquaFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MisurazioniAcquaFindUniqueArgs<ExtArgs>>
    ): Prisma__MisurazioniAcquaClient<$Result.GetResult<Prisma.$MisurazioniAcquaPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MisurazioniAcqua that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MisurazioniAcquaFindUniqueOrThrowArgs} args - Arguments to find a MisurazioniAcqua
     * @example
     * // Get one MisurazioniAcqua
     * const misurazioniAcqua = await prisma.misurazioniAcqua.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MisurazioniAcquaFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MisurazioniAcquaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MisurazioniAcquaClient<$Result.GetResult<Prisma.$MisurazioniAcquaPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MisurazioniAcqua that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MisurazioniAcquaFindFirstArgs} args - Arguments to find a MisurazioniAcqua
     * @example
     * // Get one MisurazioniAcqua
     * const misurazioniAcqua = await prisma.misurazioniAcqua.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MisurazioniAcquaFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MisurazioniAcquaFindFirstArgs<ExtArgs>>
    ): Prisma__MisurazioniAcquaClient<$Result.GetResult<Prisma.$MisurazioniAcquaPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MisurazioniAcqua that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MisurazioniAcquaFindFirstOrThrowArgs} args - Arguments to find a MisurazioniAcqua
     * @example
     * // Get one MisurazioniAcqua
     * const misurazioniAcqua = await prisma.misurazioniAcqua.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MisurazioniAcquaFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MisurazioniAcquaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MisurazioniAcquaClient<$Result.GetResult<Prisma.$MisurazioniAcquaPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MisurazioniAcquas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MisurazioniAcquaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MisurazioniAcquas
     * const misurazioniAcquas = await prisma.misurazioniAcqua.findMany()
     * 
     * // Get first 10 MisurazioniAcquas
     * const misurazioniAcquas = await prisma.misurazioniAcqua.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const misurazioniAcquaWithIdOnly = await prisma.misurazioniAcqua.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MisurazioniAcquaFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MisurazioniAcquaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MisurazioniAcquaPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MisurazioniAcqua.
     * @param {MisurazioniAcquaCreateArgs} args - Arguments to create a MisurazioniAcqua.
     * @example
     * // Create one MisurazioniAcqua
     * const MisurazioniAcqua = await prisma.misurazioniAcqua.create({
     *   data: {
     *     // ... data to create a MisurazioniAcqua
     *   }
     * })
     * 
    **/
    create<T extends MisurazioniAcquaCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MisurazioniAcquaCreateArgs<ExtArgs>>
    ): Prisma__MisurazioniAcquaClient<$Result.GetResult<Prisma.$MisurazioniAcquaPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MisurazioniAcquas.
     *     @param {MisurazioniAcquaCreateManyArgs} args - Arguments to create many MisurazioniAcquas.
     *     @example
     *     // Create many MisurazioniAcquas
     *     const misurazioniAcqua = await prisma.misurazioniAcqua.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MisurazioniAcquaCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MisurazioniAcquaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MisurazioniAcqua.
     * @param {MisurazioniAcquaDeleteArgs} args - Arguments to delete one MisurazioniAcqua.
     * @example
     * // Delete one MisurazioniAcqua
     * const MisurazioniAcqua = await prisma.misurazioniAcqua.delete({
     *   where: {
     *     // ... filter to delete one MisurazioniAcqua
     *   }
     * })
     * 
    **/
    delete<T extends MisurazioniAcquaDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MisurazioniAcquaDeleteArgs<ExtArgs>>
    ): Prisma__MisurazioniAcquaClient<$Result.GetResult<Prisma.$MisurazioniAcquaPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MisurazioniAcqua.
     * @param {MisurazioniAcquaUpdateArgs} args - Arguments to update one MisurazioniAcqua.
     * @example
     * // Update one MisurazioniAcqua
     * const misurazioniAcqua = await prisma.misurazioniAcqua.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MisurazioniAcquaUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MisurazioniAcquaUpdateArgs<ExtArgs>>
    ): Prisma__MisurazioniAcquaClient<$Result.GetResult<Prisma.$MisurazioniAcquaPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MisurazioniAcquas.
     * @param {MisurazioniAcquaDeleteManyArgs} args - Arguments to filter MisurazioniAcquas to delete.
     * @example
     * // Delete a few MisurazioniAcquas
     * const { count } = await prisma.misurazioniAcqua.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MisurazioniAcquaDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MisurazioniAcquaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MisurazioniAcquas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MisurazioniAcquaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MisurazioniAcquas
     * const misurazioniAcqua = await prisma.misurazioniAcqua.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MisurazioniAcquaUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MisurazioniAcquaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MisurazioniAcqua.
     * @param {MisurazioniAcquaUpsertArgs} args - Arguments to update or create a MisurazioniAcqua.
     * @example
     * // Update or create a MisurazioniAcqua
     * const misurazioniAcqua = await prisma.misurazioniAcqua.upsert({
     *   create: {
     *     // ... data to create a MisurazioniAcqua
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MisurazioniAcqua we want to update
     *   }
     * })
    **/
    upsert<T extends MisurazioniAcquaUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MisurazioniAcquaUpsertArgs<ExtArgs>>
    ): Prisma__MisurazioniAcquaClient<$Result.GetResult<Prisma.$MisurazioniAcquaPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MisurazioniAcquas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MisurazioniAcquaCountArgs} args - Arguments to filter MisurazioniAcquas to count.
     * @example
     * // Count the number of MisurazioniAcquas
     * const count = await prisma.misurazioniAcqua.count({
     *   where: {
     *     // ... the filter for the MisurazioniAcquas we want to count
     *   }
     * })
    **/
    count<T extends MisurazioniAcquaCountArgs>(
      args?: Subset<T, MisurazioniAcquaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MisurazioniAcquaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MisurazioniAcqua.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MisurazioniAcquaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MisurazioniAcquaAggregateArgs>(args: Subset<T, MisurazioniAcquaAggregateArgs>): Prisma.PrismaPromise<GetMisurazioniAcquaAggregateType<T>>

    /**
     * Group by MisurazioniAcqua.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MisurazioniAcquaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MisurazioniAcquaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MisurazioniAcquaGroupByArgs['orderBy'] }
        : { orderBy?: MisurazioniAcquaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MisurazioniAcquaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMisurazioniAcquaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MisurazioniAcqua model
   */
  readonly fields: MisurazioniAcquaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MisurazioniAcqua.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MisurazioniAcquaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    dispositivo<T extends AcquaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AcquaDefaultArgs<ExtArgs>>): Prisma__AcquaClient<$Result.GetResult<Prisma.$AcquaPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MisurazioniAcqua model
   */ 
  interface MisurazioniAcquaFieldRefs {
    readonly id: FieldRef<"MisurazioniAcqua", 'Int'>
    readonly pH: FieldRef<"MisurazioniAcqua", 'Float'>
    readonly metalli: FieldRef<"MisurazioniAcqua", 'Float'>
    readonly data: FieldRef<"MisurazioniAcqua", 'DateTime'>
    readonly dispId: FieldRef<"MisurazioniAcqua", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * MisurazioniAcqua findUnique
   */
  export type MisurazioniAcquaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MisurazioniAcqua
     */
    select?: MisurazioniAcquaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MisurazioniAcquaInclude<ExtArgs> | null
    /**
     * Filter, which MisurazioniAcqua to fetch.
     */
    where: MisurazioniAcquaWhereUniqueInput
  }


  /**
   * MisurazioniAcqua findUniqueOrThrow
   */
  export type MisurazioniAcquaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MisurazioniAcqua
     */
    select?: MisurazioniAcquaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MisurazioniAcquaInclude<ExtArgs> | null
    /**
     * Filter, which MisurazioniAcqua to fetch.
     */
    where: MisurazioniAcquaWhereUniqueInput
  }


  /**
   * MisurazioniAcqua findFirst
   */
  export type MisurazioniAcquaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MisurazioniAcqua
     */
    select?: MisurazioniAcquaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MisurazioniAcquaInclude<ExtArgs> | null
    /**
     * Filter, which MisurazioniAcqua to fetch.
     */
    where?: MisurazioniAcquaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MisurazioniAcquas to fetch.
     */
    orderBy?: MisurazioniAcquaOrderByWithRelationInput | MisurazioniAcquaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MisurazioniAcquas.
     */
    cursor?: MisurazioniAcquaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MisurazioniAcquas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MisurazioniAcquas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MisurazioniAcquas.
     */
    distinct?: MisurazioniAcquaScalarFieldEnum | MisurazioniAcquaScalarFieldEnum[]
  }


  /**
   * MisurazioniAcqua findFirstOrThrow
   */
  export type MisurazioniAcquaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MisurazioniAcqua
     */
    select?: MisurazioniAcquaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MisurazioniAcquaInclude<ExtArgs> | null
    /**
     * Filter, which MisurazioniAcqua to fetch.
     */
    where?: MisurazioniAcquaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MisurazioniAcquas to fetch.
     */
    orderBy?: MisurazioniAcquaOrderByWithRelationInput | MisurazioniAcquaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MisurazioniAcquas.
     */
    cursor?: MisurazioniAcquaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MisurazioniAcquas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MisurazioniAcquas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MisurazioniAcquas.
     */
    distinct?: MisurazioniAcquaScalarFieldEnum | MisurazioniAcquaScalarFieldEnum[]
  }


  /**
   * MisurazioniAcqua findMany
   */
  export type MisurazioniAcquaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MisurazioniAcqua
     */
    select?: MisurazioniAcquaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MisurazioniAcquaInclude<ExtArgs> | null
    /**
     * Filter, which MisurazioniAcquas to fetch.
     */
    where?: MisurazioniAcquaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MisurazioniAcquas to fetch.
     */
    orderBy?: MisurazioniAcquaOrderByWithRelationInput | MisurazioniAcquaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MisurazioniAcquas.
     */
    cursor?: MisurazioniAcquaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MisurazioniAcquas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MisurazioniAcquas.
     */
    skip?: number
    distinct?: MisurazioniAcquaScalarFieldEnum | MisurazioniAcquaScalarFieldEnum[]
  }


  /**
   * MisurazioniAcqua create
   */
  export type MisurazioniAcquaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MisurazioniAcqua
     */
    select?: MisurazioniAcquaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MisurazioniAcquaInclude<ExtArgs> | null
    /**
     * The data needed to create a MisurazioniAcqua.
     */
    data: XOR<MisurazioniAcquaCreateInput, MisurazioniAcquaUncheckedCreateInput>
  }


  /**
   * MisurazioniAcqua createMany
   */
  export type MisurazioniAcquaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MisurazioniAcquas.
     */
    data: MisurazioniAcquaCreateManyInput | MisurazioniAcquaCreateManyInput[]
  }


  /**
   * MisurazioniAcqua update
   */
  export type MisurazioniAcquaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MisurazioniAcqua
     */
    select?: MisurazioniAcquaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MisurazioniAcquaInclude<ExtArgs> | null
    /**
     * The data needed to update a MisurazioniAcqua.
     */
    data: XOR<MisurazioniAcquaUpdateInput, MisurazioniAcquaUncheckedUpdateInput>
    /**
     * Choose, which MisurazioniAcqua to update.
     */
    where: MisurazioniAcquaWhereUniqueInput
  }


  /**
   * MisurazioniAcqua updateMany
   */
  export type MisurazioniAcquaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MisurazioniAcquas.
     */
    data: XOR<MisurazioniAcquaUpdateManyMutationInput, MisurazioniAcquaUncheckedUpdateManyInput>
    /**
     * Filter which MisurazioniAcquas to update
     */
    where?: MisurazioniAcquaWhereInput
  }


  /**
   * MisurazioniAcqua upsert
   */
  export type MisurazioniAcquaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MisurazioniAcqua
     */
    select?: MisurazioniAcquaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MisurazioniAcquaInclude<ExtArgs> | null
    /**
     * The filter to search for the MisurazioniAcqua to update in case it exists.
     */
    where: MisurazioniAcquaWhereUniqueInput
    /**
     * In case the MisurazioniAcqua found by the `where` argument doesn't exist, create a new MisurazioniAcqua with this data.
     */
    create: XOR<MisurazioniAcquaCreateInput, MisurazioniAcquaUncheckedCreateInput>
    /**
     * In case the MisurazioniAcqua was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MisurazioniAcquaUpdateInput, MisurazioniAcquaUncheckedUpdateInput>
  }


  /**
   * MisurazioniAcqua delete
   */
  export type MisurazioniAcquaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MisurazioniAcqua
     */
    select?: MisurazioniAcquaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MisurazioniAcquaInclude<ExtArgs> | null
    /**
     * Filter which MisurazioniAcqua to delete.
     */
    where: MisurazioniAcquaWhereUniqueInput
  }


  /**
   * MisurazioniAcqua deleteMany
   */
  export type MisurazioniAcquaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MisurazioniAcquas to delete
     */
    where?: MisurazioniAcquaWhereInput
  }


  /**
   * MisurazioniAcqua without action
   */
  export type MisurazioniAcquaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MisurazioniAcqua
     */
    select?: MisurazioniAcquaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MisurazioniAcquaInclude<ExtArgs> | null
  }



  /**
   * Model Aria
   */

  export type AggregateAria = {
    _count: AriaCountAggregateOutputType | null
    _avg: AriaAvgAggregateOutputType | null
    _sum: AriaSumAggregateOutputType | null
    _min: AriaMinAggregateOutputType | null
    _max: AriaMaxAggregateOutputType | null
  }

  export type AriaAvgAggregateOutputType = {
    idDispositivo: number | null
  }

  export type AriaSumAggregateOutputType = {
    idDispositivo: number | null
  }

  export type AriaMinAggregateOutputType = {
    idDispositivo: number | null
  }

  export type AriaMaxAggregateOutputType = {
    idDispositivo: number | null
  }

  export type AriaCountAggregateOutputType = {
    idDispositivo: number
    _all: number
  }


  export type AriaAvgAggregateInputType = {
    idDispositivo?: true
  }

  export type AriaSumAggregateInputType = {
    idDispositivo?: true
  }

  export type AriaMinAggregateInputType = {
    idDispositivo?: true
  }

  export type AriaMaxAggregateInputType = {
    idDispositivo?: true
  }

  export type AriaCountAggregateInputType = {
    idDispositivo?: true
    _all?: true
  }

  export type AriaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Aria to aggregate.
     */
    where?: AriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Arias to fetch.
     */
    orderBy?: AriaOrderByWithRelationInput | AriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Arias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Arias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Arias
    **/
    _count?: true | AriaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AriaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AriaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AriaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AriaMaxAggregateInputType
  }

  export type GetAriaAggregateType<T extends AriaAggregateArgs> = {
        [P in keyof T & keyof AggregateAria]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAria[P]>
      : GetScalarType<T[P], AggregateAria[P]>
  }




  export type AriaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AriaWhereInput
    orderBy?: AriaOrderByWithAggregationInput | AriaOrderByWithAggregationInput[]
    by: AriaScalarFieldEnum[] | AriaScalarFieldEnum
    having?: AriaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AriaCountAggregateInputType | true
    _avg?: AriaAvgAggregateInputType
    _sum?: AriaSumAggregateInputType
    _min?: AriaMinAggregateInputType
    _max?: AriaMaxAggregateInputType
  }

  export type AriaGroupByOutputType = {
    idDispositivo: number
    _count: AriaCountAggregateOutputType | null
    _avg: AriaAvgAggregateOutputType | null
    _sum: AriaSumAggregateOutputType | null
    _min: AriaMinAggregateOutputType | null
    _max: AriaMaxAggregateOutputType | null
  }

  type GetAriaGroupByPayload<T extends AriaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AriaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AriaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AriaGroupByOutputType[P]>
            : GetScalarType<T[P], AriaGroupByOutputType[P]>
        }
      >
    >


  export type AriaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idDispositivo?: boolean
    device?: boolean | DispositivoDefaultArgs<ExtArgs>
    misurazioneAria?: boolean | Aria$misurazioneAriaArgs<ExtArgs>
    _count?: boolean | AriaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aria"]>

  export type AriaSelectScalar = {
    idDispositivo?: boolean
  }

  export type AriaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    device?: boolean | DispositivoDefaultArgs<ExtArgs>
    misurazioneAria?: boolean | Aria$misurazioneAriaArgs<ExtArgs>
    _count?: boolean | AriaCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $AriaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Aria"
    objects: {
      device: Prisma.$DispositivoPayload<ExtArgs>
      misurazioneAria: Prisma.$MisurazioniAriaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idDispositivo: number
    }, ExtArgs["result"]["aria"]>
    composites: {}
  }


  type AriaGetPayload<S extends boolean | null | undefined | AriaDefaultArgs> = $Result.GetResult<Prisma.$AriaPayload, S>

  type AriaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AriaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AriaCountAggregateInputType | true
    }

  export interface AriaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Aria'], meta: { name: 'Aria' } }
    /**
     * Find zero or one Aria that matches the filter.
     * @param {AriaFindUniqueArgs} args - Arguments to find a Aria
     * @example
     * // Get one Aria
     * const aria = await prisma.aria.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AriaFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AriaFindUniqueArgs<ExtArgs>>
    ): Prisma__AriaClient<$Result.GetResult<Prisma.$AriaPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Aria that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AriaFindUniqueOrThrowArgs} args - Arguments to find a Aria
     * @example
     * // Get one Aria
     * const aria = await prisma.aria.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AriaFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AriaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AriaClient<$Result.GetResult<Prisma.$AriaPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Aria that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AriaFindFirstArgs} args - Arguments to find a Aria
     * @example
     * // Get one Aria
     * const aria = await prisma.aria.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AriaFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AriaFindFirstArgs<ExtArgs>>
    ): Prisma__AriaClient<$Result.GetResult<Prisma.$AriaPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Aria that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AriaFindFirstOrThrowArgs} args - Arguments to find a Aria
     * @example
     * // Get one Aria
     * const aria = await prisma.aria.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AriaFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AriaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AriaClient<$Result.GetResult<Prisma.$AriaPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Arias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AriaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Arias
     * const arias = await prisma.aria.findMany()
     * 
     * // Get first 10 Arias
     * const arias = await prisma.aria.findMany({ take: 10 })
     * 
     * // Only select the `idDispositivo`
     * const ariaWithIdDispositivoOnly = await prisma.aria.findMany({ select: { idDispositivo: true } })
     * 
    **/
    findMany<T extends AriaFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AriaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AriaPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Aria.
     * @param {AriaCreateArgs} args - Arguments to create a Aria.
     * @example
     * // Create one Aria
     * const Aria = await prisma.aria.create({
     *   data: {
     *     // ... data to create a Aria
     *   }
     * })
     * 
    **/
    create<T extends AriaCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AriaCreateArgs<ExtArgs>>
    ): Prisma__AriaClient<$Result.GetResult<Prisma.$AriaPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Arias.
     *     @param {AriaCreateManyArgs} args - Arguments to create many Arias.
     *     @example
     *     // Create many Arias
     *     const aria = await prisma.aria.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AriaCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AriaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Aria.
     * @param {AriaDeleteArgs} args - Arguments to delete one Aria.
     * @example
     * // Delete one Aria
     * const Aria = await prisma.aria.delete({
     *   where: {
     *     // ... filter to delete one Aria
     *   }
     * })
     * 
    **/
    delete<T extends AriaDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AriaDeleteArgs<ExtArgs>>
    ): Prisma__AriaClient<$Result.GetResult<Prisma.$AriaPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Aria.
     * @param {AriaUpdateArgs} args - Arguments to update one Aria.
     * @example
     * // Update one Aria
     * const aria = await prisma.aria.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AriaUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AriaUpdateArgs<ExtArgs>>
    ): Prisma__AriaClient<$Result.GetResult<Prisma.$AriaPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Arias.
     * @param {AriaDeleteManyArgs} args - Arguments to filter Arias to delete.
     * @example
     * // Delete a few Arias
     * const { count } = await prisma.aria.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AriaDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AriaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Arias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AriaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Arias
     * const aria = await prisma.aria.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AriaUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AriaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Aria.
     * @param {AriaUpsertArgs} args - Arguments to update or create a Aria.
     * @example
     * // Update or create a Aria
     * const aria = await prisma.aria.upsert({
     *   create: {
     *     // ... data to create a Aria
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Aria we want to update
     *   }
     * })
    **/
    upsert<T extends AriaUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AriaUpsertArgs<ExtArgs>>
    ): Prisma__AriaClient<$Result.GetResult<Prisma.$AriaPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Arias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AriaCountArgs} args - Arguments to filter Arias to count.
     * @example
     * // Count the number of Arias
     * const count = await prisma.aria.count({
     *   where: {
     *     // ... the filter for the Arias we want to count
     *   }
     * })
    **/
    count<T extends AriaCountArgs>(
      args?: Subset<T, AriaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AriaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Aria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AriaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AriaAggregateArgs>(args: Subset<T, AriaAggregateArgs>): Prisma.PrismaPromise<GetAriaAggregateType<T>>

    /**
     * Group by Aria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AriaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AriaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AriaGroupByArgs['orderBy'] }
        : { orderBy?: AriaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AriaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAriaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Aria model
   */
  readonly fields: AriaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Aria.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AriaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    device<T extends DispositivoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DispositivoDefaultArgs<ExtArgs>>): Prisma__DispositivoClient<$Result.GetResult<Prisma.$DispositivoPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    misurazioneAria<T extends Aria$misurazioneAriaArgs<ExtArgs> = {}>(args?: Subset<T, Aria$misurazioneAriaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MisurazioniAriaPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Aria model
   */ 
  interface AriaFieldRefs {
    readonly idDispositivo: FieldRef<"Aria", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Aria findUnique
   */
  export type AriaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aria
     */
    select?: AriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AriaInclude<ExtArgs> | null
    /**
     * Filter, which Aria to fetch.
     */
    where: AriaWhereUniqueInput
  }


  /**
   * Aria findUniqueOrThrow
   */
  export type AriaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aria
     */
    select?: AriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AriaInclude<ExtArgs> | null
    /**
     * Filter, which Aria to fetch.
     */
    where: AriaWhereUniqueInput
  }


  /**
   * Aria findFirst
   */
  export type AriaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aria
     */
    select?: AriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AriaInclude<ExtArgs> | null
    /**
     * Filter, which Aria to fetch.
     */
    where?: AriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Arias to fetch.
     */
    orderBy?: AriaOrderByWithRelationInput | AriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Arias.
     */
    cursor?: AriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Arias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Arias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Arias.
     */
    distinct?: AriaScalarFieldEnum | AriaScalarFieldEnum[]
  }


  /**
   * Aria findFirstOrThrow
   */
  export type AriaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aria
     */
    select?: AriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AriaInclude<ExtArgs> | null
    /**
     * Filter, which Aria to fetch.
     */
    where?: AriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Arias to fetch.
     */
    orderBy?: AriaOrderByWithRelationInput | AriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Arias.
     */
    cursor?: AriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Arias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Arias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Arias.
     */
    distinct?: AriaScalarFieldEnum | AriaScalarFieldEnum[]
  }


  /**
   * Aria findMany
   */
  export type AriaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aria
     */
    select?: AriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AriaInclude<ExtArgs> | null
    /**
     * Filter, which Arias to fetch.
     */
    where?: AriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Arias to fetch.
     */
    orderBy?: AriaOrderByWithRelationInput | AriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Arias.
     */
    cursor?: AriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Arias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Arias.
     */
    skip?: number
    distinct?: AriaScalarFieldEnum | AriaScalarFieldEnum[]
  }


  /**
   * Aria create
   */
  export type AriaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aria
     */
    select?: AriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AriaInclude<ExtArgs> | null
    /**
     * The data needed to create a Aria.
     */
    data: XOR<AriaCreateInput, AriaUncheckedCreateInput>
  }


  /**
   * Aria createMany
   */
  export type AriaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Arias.
     */
    data: AriaCreateManyInput | AriaCreateManyInput[]
  }


  /**
   * Aria update
   */
  export type AriaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aria
     */
    select?: AriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AriaInclude<ExtArgs> | null
    /**
     * The data needed to update a Aria.
     */
    data: XOR<AriaUpdateInput, AriaUncheckedUpdateInput>
    /**
     * Choose, which Aria to update.
     */
    where: AriaWhereUniqueInput
  }


  /**
   * Aria updateMany
   */
  export type AriaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Arias.
     */
    data: XOR<AriaUpdateManyMutationInput, AriaUncheckedUpdateManyInput>
    /**
     * Filter which Arias to update
     */
    where?: AriaWhereInput
  }


  /**
   * Aria upsert
   */
  export type AriaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aria
     */
    select?: AriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AriaInclude<ExtArgs> | null
    /**
     * The filter to search for the Aria to update in case it exists.
     */
    where: AriaWhereUniqueInput
    /**
     * In case the Aria found by the `where` argument doesn't exist, create a new Aria with this data.
     */
    create: XOR<AriaCreateInput, AriaUncheckedCreateInput>
    /**
     * In case the Aria was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AriaUpdateInput, AriaUncheckedUpdateInput>
  }


  /**
   * Aria delete
   */
  export type AriaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aria
     */
    select?: AriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AriaInclude<ExtArgs> | null
    /**
     * Filter which Aria to delete.
     */
    where: AriaWhereUniqueInput
  }


  /**
   * Aria deleteMany
   */
  export type AriaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Arias to delete
     */
    where?: AriaWhereInput
  }


  /**
   * Aria.misurazioneAria
   */
  export type Aria$misurazioneAriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MisurazioniAria
     */
    select?: MisurazioniAriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MisurazioniAriaInclude<ExtArgs> | null
    where?: MisurazioniAriaWhereInput
    orderBy?: MisurazioniAriaOrderByWithRelationInput | MisurazioniAriaOrderByWithRelationInput[]
    cursor?: MisurazioniAriaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MisurazioniAriaScalarFieldEnum | MisurazioniAriaScalarFieldEnum[]
  }


  /**
   * Aria without action
   */
  export type AriaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Aria
     */
    select?: AriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AriaInclude<ExtArgs> | null
  }



  /**
   * Model MisurazioniAria
   */

  export type AggregateMisurazioniAria = {
    _count: MisurazioniAriaCountAggregateOutputType | null
    _avg: MisurazioniAriaAvgAggregateOutputType | null
    _sum: MisurazioniAriaSumAggregateOutputType | null
    _min: MisurazioniAriaMinAggregateOutputType | null
    _max: MisurazioniAriaMaxAggregateOutputType | null
  }

  export type MisurazioniAriaAvgAggregateOutputType = {
    id: number | null
    cov: number | null
    gas: number | null
    dispId: number | null
  }

  export type MisurazioniAriaSumAggregateOutputType = {
    id: number | null
    cov: number | null
    gas: number | null
    dispId: number | null
  }

  export type MisurazioniAriaMinAggregateOutputType = {
    id: number | null
    cov: number | null
    gas: number | null
    data: Date | null
    dispId: number | null
  }

  export type MisurazioniAriaMaxAggregateOutputType = {
    id: number | null
    cov: number | null
    gas: number | null
    data: Date | null
    dispId: number | null
  }

  export type MisurazioniAriaCountAggregateOutputType = {
    id: number
    cov: number
    gas: number
    data: number
    dispId: number
    _all: number
  }


  export type MisurazioniAriaAvgAggregateInputType = {
    id?: true
    cov?: true
    gas?: true
    dispId?: true
  }

  export type MisurazioniAriaSumAggregateInputType = {
    id?: true
    cov?: true
    gas?: true
    dispId?: true
  }

  export type MisurazioniAriaMinAggregateInputType = {
    id?: true
    cov?: true
    gas?: true
    data?: true
    dispId?: true
  }

  export type MisurazioniAriaMaxAggregateInputType = {
    id?: true
    cov?: true
    gas?: true
    data?: true
    dispId?: true
  }

  export type MisurazioniAriaCountAggregateInputType = {
    id?: true
    cov?: true
    gas?: true
    data?: true
    dispId?: true
    _all?: true
  }

  export type MisurazioniAriaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MisurazioniAria to aggregate.
     */
    where?: MisurazioniAriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MisurazioniArias to fetch.
     */
    orderBy?: MisurazioniAriaOrderByWithRelationInput | MisurazioniAriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MisurazioniAriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MisurazioniArias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MisurazioniArias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MisurazioniArias
    **/
    _count?: true | MisurazioniAriaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MisurazioniAriaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MisurazioniAriaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MisurazioniAriaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MisurazioniAriaMaxAggregateInputType
  }

  export type GetMisurazioniAriaAggregateType<T extends MisurazioniAriaAggregateArgs> = {
        [P in keyof T & keyof AggregateMisurazioniAria]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMisurazioniAria[P]>
      : GetScalarType<T[P], AggregateMisurazioniAria[P]>
  }




  export type MisurazioniAriaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MisurazioniAriaWhereInput
    orderBy?: MisurazioniAriaOrderByWithAggregationInput | MisurazioniAriaOrderByWithAggregationInput[]
    by: MisurazioniAriaScalarFieldEnum[] | MisurazioniAriaScalarFieldEnum
    having?: MisurazioniAriaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MisurazioniAriaCountAggregateInputType | true
    _avg?: MisurazioniAriaAvgAggregateInputType
    _sum?: MisurazioniAriaSumAggregateInputType
    _min?: MisurazioniAriaMinAggregateInputType
    _max?: MisurazioniAriaMaxAggregateInputType
  }

  export type MisurazioniAriaGroupByOutputType = {
    id: number
    cov: number
    gas: number
    data: Date
    dispId: number
    _count: MisurazioniAriaCountAggregateOutputType | null
    _avg: MisurazioniAriaAvgAggregateOutputType | null
    _sum: MisurazioniAriaSumAggregateOutputType | null
    _min: MisurazioniAriaMinAggregateOutputType | null
    _max: MisurazioniAriaMaxAggregateOutputType | null
  }

  type GetMisurazioniAriaGroupByPayload<T extends MisurazioniAriaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MisurazioniAriaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MisurazioniAriaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MisurazioniAriaGroupByOutputType[P]>
            : GetScalarType<T[P], MisurazioniAriaGroupByOutputType[P]>
        }
      >
    >


  export type MisurazioniAriaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cov?: boolean
    gas?: boolean
    data?: boolean
    dispId?: boolean
    dispositivo?: boolean | AriaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["misurazioniAria"]>

  export type MisurazioniAriaSelectScalar = {
    id?: boolean
    cov?: boolean
    gas?: boolean
    data?: boolean
    dispId?: boolean
  }

  export type MisurazioniAriaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dispositivo?: boolean | AriaDefaultArgs<ExtArgs>
  }


  export type $MisurazioniAriaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MisurazioniAria"
    objects: {
      dispositivo: Prisma.$AriaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      cov: number
      gas: number
      data: Date
      dispId: number
    }, ExtArgs["result"]["misurazioniAria"]>
    composites: {}
  }


  type MisurazioniAriaGetPayload<S extends boolean | null | undefined | MisurazioniAriaDefaultArgs> = $Result.GetResult<Prisma.$MisurazioniAriaPayload, S>

  type MisurazioniAriaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MisurazioniAriaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MisurazioniAriaCountAggregateInputType | true
    }

  export interface MisurazioniAriaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MisurazioniAria'], meta: { name: 'MisurazioniAria' } }
    /**
     * Find zero or one MisurazioniAria that matches the filter.
     * @param {MisurazioniAriaFindUniqueArgs} args - Arguments to find a MisurazioniAria
     * @example
     * // Get one MisurazioniAria
     * const misurazioniAria = await prisma.misurazioniAria.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MisurazioniAriaFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MisurazioniAriaFindUniqueArgs<ExtArgs>>
    ): Prisma__MisurazioniAriaClient<$Result.GetResult<Prisma.$MisurazioniAriaPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MisurazioniAria that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MisurazioniAriaFindUniqueOrThrowArgs} args - Arguments to find a MisurazioniAria
     * @example
     * // Get one MisurazioniAria
     * const misurazioniAria = await prisma.misurazioniAria.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MisurazioniAriaFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MisurazioniAriaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MisurazioniAriaClient<$Result.GetResult<Prisma.$MisurazioniAriaPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MisurazioniAria that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MisurazioniAriaFindFirstArgs} args - Arguments to find a MisurazioniAria
     * @example
     * // Get one MisurazioniAria
     * const misurazioniAria = await prisma.misurazioniAria.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MisurazioniAriaFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MisurazioniAriaFindFirstArgs<ExtArgs>>
    ): Prisma__MisurazioniAriaClient<$Result.GetResult<Prisma.$MisurazioniAriaPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MisurazioniAria that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MisurazioniAriaFindFirstOrThrowArgs} args - Arguments to find a MisurazioniAria
     * @example
     * // Get one MisurazioniAria
     * const misurazioniAria = await prisma.misurazioniAria.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MisurazioniAriaFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MisurazioniAriaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MisurazioniAriaClient<$Result.GetResult<Prisma.$MisurazioniAriaPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MisurazioniArias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MisurazioniAriaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MisurazioniArias
     * const misurazioniArias = await prisma.misurazioniAria.findMany()
     * 
     * // Get first 10 MisurazioniArias
     * const misurazioniArias = await prisma.misurazioniAria.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const misurazioniAriaWithIdOnly = await prisma.misurazioniAria.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MisurazioniAriaFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MisurazioniAriaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MisurazioniAriaPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MisurazioniAria.
     * @param {MisurazioniAriaCreateArgs} args - Arguments to create a MisurazioniAria.
     * @example
     * // Create one MisurazioniAria
     * const MisurazioniAria = await prisma.misurazioniAria.create({
     *   data: {
     *     // ... data to create a MisurazioniAria
     *   }
     * })
     * 
    **/
    create<T extends MisurazioniAriaCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MisurazioniAriaCreateArgs<ExtArgs>>
    ): Prisma__MisurazioniAriaClient<$Result.GetResult<Prisma.$MisurazioniAriaPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MisurazioniArias.
     *     @param {MisurazioniAriaCreateManyArgs} args - Arguments to create many MisurazioniArias.
     *     @example
     *     // Create many MisurazioniArias
     *     const misurazioniAria = await prisma.misurazioniAria.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MisurazioniAriaCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MisurazioniAriaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MisurazioniAria.
     * @param {MisurazioniAriaDeleteArgs} args - Arguments to delete one MisurazioniAria.
     * @example
     * // Delete one MisurazioniAria
     * const MisurazioniAria = await prisma.misurazioniAria.delete({
     *   where: {
     *     // ... filter to delete one MisurazioniAria
     *   }
     * })
     * 
    **/
    delete<T extends MisurazioniAriaDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MisurazioniAriaDeleteArgs<ExtArgs>>
    ): Prisma__MisurazioniAriaClient<$Result.GetResult<Prisma.$MisurazioniAriaPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MisurazioniAria.
     * @param {MisurazioniAriaUpdateArgs} args - Arguments to update one MisurazioniAria.
     * @example
     * // Update one MisurazioniAria
     * const misurazioniAria = await prisma.misurazioniAria.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MisurazioniAriaUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MisurazioniAriaUpdateArgs<ExtArgs>>
    ): Prisma__MisurazioniAriaClient<$Result.GetResult<Prisma.$MisurazioniAriaPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MisurazioniArias.
     * @param {MisurazioniAriaDeleteManyArgs} args - Arguments to filter MisurazioniArias to delete.
     * @example
     * // Delete a few MisurazioniArias
     * const { count } = await prisma.misurazioniAria.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MisurazioniAriaDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MisurazioniAriaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MisurazioniArias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MisurazioniAriaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MisurazioniArias
     * const misurazioniAria = await prisma.misurazioniAria.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MisurazioniAriaUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MisurazioniAriaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MisurazioniAria.
     * @param {MisurazioniAriaUpsertArgs} args - Arguments to update or create a MisurazioniAria.
     * @example
     * // Update or create a MisurazioniAria
     * const misurazioniAria = await prisma.misurazioniAria.upsert({
     *   create: {
     *     // ... data to create a MisurazioniAria
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MisurazioniAria we want to update
     *   }
     * })
    **/
    upsert<T extends MisurazioniAriaUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MisurazioniAriaUpsertArgs<ExtArgs>>
    ): Prisma__MisurazioniAriaClient<$Result.GetResult<Prisma.$MisurazioniAriaPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MisurazioniArias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MisurazioniAriaCountArgs} args - Arguments to filter MisurazioniArias to count.
     * @example
     * // Count the number of MisurazioniArias
     * const count = await prisma.misurazioniAria.count({
     *   where: {
     *     // ... the filter for the MisurazioniArias we want to count
     *   }
     * })
    **/
    count<T extends MisurazioniAriaCountArgs>(
      args?: Subset<T, MisurazioniAriaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MisurazioniAriaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MisurazioniAria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MisurazioniAriaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MisurazioniAriaAggregateArgs>(args: Subset<T, MisurazioniAriaAggregateArgs>): Prisma.PrismaPromise<GetMisurazioniAriaAggregateType<T>>

    /**
     * Group by MisurazioniAria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MisurazioniAriaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MisurazioniAriaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MisurazioniAriaGroupByArgs['orderBy'] }
        : { orderBy?: MisurazioniAriaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MisurazioniAriaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMisurazioniAriaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MisurazioniAria model
   */
  readonly fields: MisurazioniAriaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MisurazioniAria.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MisurazioniAriaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    dispositivo<T extends AriaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AriaDefaultArgs<ExtArgs>>): Prisma__AriaClient<$Result.GetResult<Prisma.$AriaPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the MisurazioniAria model
   */ 
  interface MisurazioniAriaFieldRefs {
    readonly id: FieldRef<"MisurazioniAria", 'Int'>
    readonly cov: FieldRef<"MisurazioniAria", 'Float'>
    readonly gas: FieldRef<"MisurazioniAria", 'Float'>
    readonly data: FieldRef<"MisurazioniAria", 'DateTime'>
    readonly dispId: FieldRef<"MisurazioniAria", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * MisurazioniAria findUnique
   */
  export type MisurazioniAriaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MisurazioniAria
     */
    select?: MisurazioniAriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MisurazioniAriaInclude<ExtArgs> | null
    /**
     * Filter, which MisurazioniAria to fetch.
     */
    where: MisurazioniAriaWhereUniqueInput
  }


  /**
   * MisurazioniAria findUniqueOrThrow
   */
  export type MisurazioniAriaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MisurazioniAria
     */
    select?: MisurazioniAriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MisurazioniAriaInclude<ExtArgs> | null
    /**
     * Filter, which MisurazioniAria to fetch.
     */
    where: MisurazioniAriaWhereUniqueInput
  }


  /**
   * MisurazioniAria findFirst
   */
  export type MisurazioniAriaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MisurazioniAria
     */
    select?: MisurazioniAriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MisurazioniAriaInclude<ExtArgs> | null
    /**
     * Filter, which MisurazioniAria to fetch.
     */
    where?: MisurazioniAriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MisurazioniArias to fetch.
     */
    orderBy?: MisurazioniAriaOrderByWithRelationInput | MisurazioniAriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MisurazioniArias.
     */
    cursor?: MisurazioniAriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MisurazioniArias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MisurazioniArias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MisurazioniArias.
     */
    distinct?: MisurazioniAriaScalarFieldEnum | MisurazioniAriaScalarFieldEnum[]
  }


  /**
   * MisurazioniAria findFirstOrThrow
   */
  export type MisurazioniAriaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MisurazioniAria
     */
    select?: MisurazioniAriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MisurazioniAriaInclude<ExtArgs> | null
    /**
     * Filter, which MisurazioniAria to fetch.
     */
    where?: MisurazioniAriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MisurazioniArias to fetch.
     */
    orderBy?: MisurazioniAriaOrderByWithRelationInput | MisurazioniAriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MisurazioniArias.
     */
    cursor?: MisurazioniAriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MisurazioniArias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MisurazioniArias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MisurazioniArias.
     */
    distinct?: MisurazioniAriaScalarFieldEnum | MisurazioniAriaScalarFieldEnum[]
  }


  /**
   * MisurazioniAria findMany
   */
  export type MisurazioniAriaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MisurazioniAria
     */
    select?: MisurazioniAriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MisurazioniAriaInclude<ExtArgs> | null
    /**
     * Filter, which MisurazioniArias to fetch.
     */
    where?: MisurazioniAriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MisurazioniArias to fetch.
     */
    orderBy?: MisurazioniAriaOrderByWithRelationInput | MisurazioniAriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MisurazioniArias.
     */
    cursor?: MisurazioniAriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MisurazioniArias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MisurazioniArias.
     */
    skip?: number
    distinct?: MisurazioniAriaScalarFieldEnum | MisurazioniAriaScalarFieldEnum[]
  }


  /**
   * MisurazioniAria create
   */
  export type MisurazioniAriaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MisurazioniAria
     */
    select?: MisurazioniAriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MisurazioniAriaInclude<ExtArgs> | null
    /**
     * The data needed to create a MisurazioniAria.
     */
    data: XOR<MisurazioniAriaCreateInput, MisurazioniAriaUncheckedCreateInput>
  }


  /**
   * MisurazioniAria createMany
   */
  export type MisurazioniAriaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MisurazioniArias.
     */
    data: MisurazioniAriaCreateManyInput | MisurazioniAriaCreateManyInput[]
  }


  /**
   * MisurazioniAria update
   */
  export type MisurazioniAriaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MisurazioniAria
     */
    select?: MisurazioniAriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MisurazioniAriaInclude<ExtArgs> | null
    /**
     * The data needed to update a MisurazioniAria.
     */
    data: XOR<MisurazioniAriaUpdateInput, MisurazioniAriaUncheckedUpdateInput>
    /**
     * Choose, which MisurazioniAria to update.
     */
    where: MisurazioniAriaWhereUniqueInput
  }


  /**
   * MisurazioniAria updateMany
   */
  export type MisurazioniAriaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MisurazioniArias.
     */
    data: XOR<MisurazioniAriaUpdateManyMutationInput, MisurazioniAriaUncheckedUpdateManyInput>
    /**
     * Filter which MisurazioniArias to update
     */
    where?: MisurazioniAriaWhereInput
  }


  /**
   * MisurazioniAria upsert
   */
  export type MisurazioniAriaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MisurazioniAria
     */
    select?: MisurazioniAriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MisurazioniAriaInclude<ExtArgs> | null
    /**
     * The filter to search for the MisurazioniAria to update in case it exists.
     */
    where: MisurazioniAriaWhereUniqueInput
    /**
     * In case the MisurazioniAria found by the `where` argument doesn't exist, create a new MisurazioniAria with this data.
     */
    create: XOR<MisurazioniAriaCreateInput, MisurazioniAriaUncheckedCreateInput>
    /**
     * In case the MisurazioniAria was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MisurazioniAriaUpdateInput, MisurazioniAriaUncheckedUpdateInput>
  }


  /**
   * MisurazioniAria delete
   */
  export type MisurazioniAriaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MisurazioniAria
     */
    select?: MisurazioniAriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MisurazioniAriaInclude<ExtArgs> | null
    /**
     * Filter which MisurazioniAria to delete.
     */
    where: MisurazioniAriaWhereUniqueInput
  }


  /**
   * MisurazioniAria deleteMany
   */
  export type MisurazioniAriaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MisurazioniArias to delete
     */
    where?: MisurazioniAriaWhereInput
  }


  /**
   * MisurazioniAria without action
   */
  export type MisurazioniAriaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MisurazioniAria
     */
    select?: MisurazioniAriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MisurazioniAriaInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable',
    Snapshot: 'Snapshot'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const DispositivoScalarFieldEnum: {
    id: 'id',
    connectionString: 'connectionString',
    matricola: 'matricola'
  };

  export type DispositivoScalarFieldEnum = (typeof DispositivoScalarFieldEnum)[keyof typeof DispositivoScalarFieldEnum]


  export const AcquaScalarFieldEnum: {
    idDispositivo: 'idDispositivo'
  };

  export type AcquaScalarFieldEnum = (typeof AcquaScalarFieldEnum)[keyof typeof AcquaScalarFieldEnum]


  export const MisurazioniAcquaScalarFieldEnum: {
    id: 'id',
    pH: 'pH',
    metalli: 'metalli',
    data: 'data',
    dispId: 'dispId'
  };

  export type MisurazioniAcquaScalarFieldEnum = (typeof MisurazioniAcquaScalarFieldEnum)[keyof typeof MisurazioniAcquaScalarFieldEnum]


  export const AriaScalarFieldEnum: {
    idDispositivo: 'idDispositivo'
  };

  export type AriaScalarFieldEnum = (typeof AriaScalarFieldEnum)[keyof typeof AriaScalarFieldEnum]


  export const MisurazioniAriaScalarFieldEnum: {
    id: 'id',
    cov: 'cov',
    gas: 'gas',
    data: 'data',
    dispId: 'dispId'
  };

  export type MisurazioniAriaScalarFieldEnum = (typeof MisurazioniAriaScalarFieldEnum)[keyof typeof MisurazioniAriaScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    
  /**
   * Deep Input Types
   */


  export type DispositivoWhereInput = {
    AND?: DispositivoWhereInput | DispositivoWhereInput[]
    OR?: DispositivoWhereInput[]
    NOT?: DispositivoWhereInput | DispositivoWhereInput[]
    id?: IntFilter<"Dispositivo"> | number
    connectionString?: StringFilter<"Dispositivo"> | string
    matricola?: StringFilter<"Dispositivo"> | string
    water?: XOR<AcquaNullableRelationFilter, AcquaWhereInput> | null
    aria?: XOR<AriaNullableRelationFilter, AriaWhereInput> | null
  }

  export type DispositivoOrderByWithRelationInput = {
    id?: SortOrder
    connectionString?: SortOrder
    matricola?: SortOrder
    water?: AcquaOrderByWithRelationInput
    aria?: AriaOrderByWithRelationInput
  }

  export type DispositivoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    matricola?: string
    AND?: DispositivoWhereInput | DispositivoWhereInput[]
    OR?: DispositivoWhereInput[]
    NOT?: DispositivoWhereInput | DispositivoWhereInput[]
    connectionString?: StringFilter<"Dispositivo"> | string
    water?: XOR<AcquaNullableRelationFilter, AcquaWhereInput> | null
    aria?: XOR<AriaNullableRelationFilter, AriaWhereInput> | null
  }, "id" | "matricola">

  export type DispositivoOrderByWithAggregationInput = {
    id?: SortOrder
    connectionString?: SortOrder
    matricola?: SortOrder
    _count?: DispositivoCountOrderByAggregateInput
    _avg?: DispositivoAvgOrderByAggregateInput
    _max?: DispositivoMaxOrderByAggregateInput
    _min?: DispositivoMinOrderByAggregateInput
    _sum?: DispositivoSumOrderByAggregateInput
  }

  export type DispositivoScalarWhereWithAggregatesInput = {
    AND?: DispositivoScalarWhereWithAggregatesInput | DispositivoScalarWhereWithAggregatesInput[]
    OR?: DispositivoScalarWhereWithAggregatesInput[]
    NOT?: DispositivoScalarWhereWithAggregatesInput | DispositivoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Dispositivo"> | number
    connectionString?: StringWithAggregatesFilter<"Dispositivo"> | string
    matricola?: StringWithAggregatesFilter<"Dispositivo"> | string
  }

  export type AcquaWhereInput = {
    AND?: AcquaWhereInput | AcquaWhereInput[]
    OR?: AcquaWhereInput[]
    NOT?: AcquaWhereInput | AcquaWhereInput[]
    idDispositivo?: IntFilter<"Acqua"> | number
    device?: XOR<DispositivoRelationFilter, DispositivoWhereInput>
    misurazioniAcqua?: MisurazioniAcquaListRelationFilter
  }

  export type AcquaOrderByWithRelationInput = {
    idDispositivo?: SortOrder
    device?: DispositivoOrderByWithRelationInput
    misurazioniAcqua?: MisurazioniAcquaOrderByRelationAggregateInput
  }

  export type AcquaWhereUniqueInput = Prisma.AtLeast<{
    idDispositivo?: number
    AND?: AcquaWhereInput | AcquaWhereInput[]
    OR?: AcquaWhereInput[]
    NOT?: AcquaWhereInput | AcquaWhereInput[]
    device?: XOR<DispositivoRelationFilter, DispositivoWhereInput>
    misurazioniAcqua?: MisurazioniAcquaListRelationFilter
  }, "idDispositivo">

  export type AcquaOrderByWithAggregationInput = {
    idDispositivo?: SortOrder
    _count?: AcquaCountOrderByAggregateInput
    _avg?: AcquaAvgOrderByAggregateInput
    _max?: AcquaMaxOrderByAggregateInput
    _min?: AcquaMinOrderByAggregateInput
    _sum?: AcquaSumOrderByAggregateInput
  }

  export type AcquaScalarWhereWithAggregatesInput = {
    AND?: AcquaScalarWhereWithAggregatesInput | AcquaScalarWhereWithAggregatesInput[]
    OR?: AcquaScalarWhereWithAggregatesInput[]
    NOT?: AcquaScalarWhereWithAggregatesInput | AcquaScalarWhereWithAggregatesInput[]
    idDispositivo?: IntWithAggregatesFilter<"Acqua"> | number
  }

  export type MisurazioniAcquaWhereInput = {
    AND?: MisurazioniAcquaWhereInput | MisurazioniAcquaWhereInput[]
    OR?: MisurazioniAcquaWhereInput[]
    NOT?: MisurazioniAcquaWhereInput | MisurazioniAcquaWhereInput[]
    id?: IntFilter<"MisurazioniAcqua"> | number
    pH?: FloatFilter<"MisurazioniAcqua"> | number
    metalli?: FloatFilter<"MisurazioniAcqua"> | number
    data?: DateTimeFilter<"MisurazioniAcqua"> | Date | string
    dispId?: IntFilter<"MisurazioniAcqua"> | number
    dispositivo?: XOR<AcquaRelationFilter, AcquaWhereInput>
  }

  export type MisurazioniAcquaOrderByWithRelationInput = {
    id?: SortOrder
    pH?: SortOrder
    metalli?: SortOrder
    data?: SortOrder
    dispId?: SortOrder
    dispositivo?: AcquaOrderByWithRelationInput
  }

  export type MisurazioniAcquaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MisurazioniAcquaWhereInput | MisurazioniAcquaWhereInput[]
    OR?: MisurazioniAcquaWhereInput[]
    NOT?: MisurazioniAcquaWhereInput | MisurazioniAcquaWhereInput[]
    pH?: FloatFilter<"MisurazioniAcqua"> | number
    metalli?: FloatFilter<"MisurazioniAcqua"> | number
    data?: DateTimeFilter<"MisurazioniAcqua"> | Date | string
    dispId?: IntFilter<"MisurazioniAcqua"> | number
    dispositivo?: XOR<AcquaRelationFilter, AcquaWhereInput>
  }, "id">

  export type MisurazioniAcquaOrderByWithAggregationInput = {
    id?: SortOrder
    pH?: SortOrder
    metalli?: SortOrder
    data?: SortOrder
    dispId?: SortOrder
    _count?: MisurazioniAcquaCountOrderByAggregateInput
    _avg?: MisurazioniAcquaAvgOrderByAggregateInput
    _max?: MisurazioniAcquaMaxOrderByAggregateInput
    _min?: MisurazioniAcquaMinOrderByAggregateInput
    _sum?: MisurazioniAcquaSumOrderByAggregateInput
  }

  export type MisurazioniAcquaScalarWhereWithAggregatesInput = {
    AND?: MisurazioniAcquaScalarWhereWithAggregatesInput | MisurazioniAcquaScalarWhereWithAggregatesInput[]
    OR?: MisurazioniAcquaScalarWhereWithAggregatesInput[]
    NOT?: MisurazioniAcquaScalarWhereWithAggregatesInput | MisurazioniAcquaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MisurazioniAcqua"> | number
    pH?: FloatWithAggregatesFilter<"MisurazioniAcqua"> | number
    metalli?: FloatWithAggregatesFilter<"MisurazioniAcqua"> | number
    data?: DateTimeWithAggregatesFilter<"MisurazioniAcqua"> | Date | string
    dispId?: IntWithAggregatesFilter<"MisurazioniAcqua"> | number
  }

  export type AriaWhereInput = {
    AND?: AriaWhereInput | AriaWhereInput[]
    OR?: AriaWhereInput[]
    NOT?: AriaWhereInput | AriaWhereInput[]
    idDispositivo?: IntFilter<"Aria"> | number
    device?: XOR<DispositivoRelationFilter, DispositivoWhereInput>
    misurazioneAria?: MisurazioniAriaListRelationFilter
  }

  export type AriaOrderByWithRelationInput = {
    idDispositivo?: SortOrder
    device?: DispositivoOrderByWithRelationInput
    misurazioneAria?: MisurazioniAriaOrderByRelationAggregateInput
  }

  export type AriaWhereUniqueInput = Prisma.AtLeast<{
    idDispositivo?: number
    AND?: AriaWhereInput | AriaWhereInput[]
    OR?: AriaWhereInput[]
    NOT?: AriaWhereInput | AriaWhereInput[]
    device?: XOR<DispositivoRelationFilter, DispositivoWhereInput>
    misurazioneAria?: MisurazioniAriaListRelationFilter
  }, "idDispositivo">

  export type AriaOrderByWithAggregationInput = {
    idDispositivo?: SortOrder
    _count?: AriaCountOrderByAggregateInput
    _avg?: AriaAvgOrderByAggregateInput
    _max?: AriaMaxOrderByAggregateInput
    _min?: AriaMinOrderByAggregateInput
    _sum?: AriaSumOrderByAggregateInput
  }

  export type AriaScalarWhereWithAggregatesInput = {
    AND?: AriaScalarWhereWithAggregatesInput | AriaScalarWhereWithAggregatesInput[]
    OR?: AriaScalarWhereWithAggregatesInput[]
    NOT?: AriaScalarWhereWithAggregatesInput | AriaScalarWhereWithAggregatesInput[]
    idDispositivo?: IntWithAggregatesFilter<"Aria"> | number
  }

  export type MisurazioniAriaWhereInput = {
    AND?: MisurazioniAriaWhereInput | MisurazioniAriaWhereInput[]
    OR?: MisurazioniAriaWhereInput[]
    NOT?: MisurazioniAriaWhereInput | MisurazioniAriaWhereInput[]
    id?: IntFilter<"MisurazioniAria"> | number
    cov?: FloatFilter<"MisurazioniAria"> | number
    gas?: FloatFilter<"MisurazioniAria"> | number
    data?: DateTimeFilter<"MisurazioniAria"> | Date | string
    dispId?: IntFilter<"MisurazioniAria"> | number
    dispositivo?: XOR<AriaRelationFilter, AriaWhereInput>
  }

  export type MisurazioniAriaOrderByWithRelationInput = {
    id?: SortOrder
    cov?: SortOrder
    gas?: SortOrder
    data?: SortOrder
    dispId?: SortOrder
    dispositivo?: AriaOrderByWithRelationInput
  }

  export type MisurazioniAriaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MisurazioniAriaWhereInput | MisurazioniAriaWhereInput[]
    OR?: MisurazioniAriaWhereInput[]
    NOT?: MisurazioniAriaWhereInput | MisurazioniAriaWhereInput[]
    cov?: FloatFilter<"MisurazioniAria"> | number
    gas?: FloatFilter<"MisurazioniAria"> | number
    data?: DateTimeFilter<"MisurazioniAria"> | Date | string
    dispId?: IntFilter<"MisurazioniAria"> | number
    dispositivo?: XOR<AriaRelationFilter, AriaWhereInput>
  }, "id">

  export type MisurazioniAriaOrderByWithAggregationInput = {
    id?: SortOrder
    cov?: SortOrder
    gas?: SortOrder
    data?: SortOrder
    dispId?: SortOrder
    _count?: MisurazioniAriaCountOrderByAggregateInput
    _avg?: MisurazioniAriaAvgOrderByAggregateInput
    _max?: MisurazioniAriaMaxOrderByAggregateInput
    _min?: MisurazioniAriaMinOrderByAggregateInput
    _sum?: MisurazioniAriaSumOrderByAggregateInput
  }

  export type MisurazioniAriaScalarWhereWithAggregatesInput = {
    AND?: MisurazioniAriaScalarWhereWithAggregatesInput | MisurazioniAriaScalarWhereWithAggregatesInput[]
    OR?: MisurazioniAriaScalarWhereWithAggregatesInput[]
    NOT?: MisurazioniAriaScalarWhereWithAggregatesInput | MisurazioniAriaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MisurazioniAria"> | number
    cov?: FloatWithAggregatesFilter<"MisurazioniAria"> | number
    gas?: FloatWithAggregatesFilter<"MisurazioniAria"> | number
    data?: DateTimeWithAggregatesFilter<"MisurazioniAria"> | Date | string
    dispId?: IntWithAggregatesFilter<"MisurazioniAria"> | number
  }

  export type DispositivoCreateInput = {
    connectionString: string
    matricola: string
    water?: AcquaCreateNestedOneWithoutDeviceInput
    aria?: AriaCreateNestedOneWithoutDeviceInput
  }

  export type DispositivoUncheckedCreateInput = {
    id?: number
    connectionString: string
    matricola: string
    water?: AcquaUncheckedCreateNestedOneWithoutDeviceInput
    aria?: AriaUncheckedCreateNestedOneWithoutDeviceInput
  }

  export type DispositivoUpdateInput = {
    connectionString?: StringFieldUpdateOperationsInput | string
    matricola?: StringFieldUpdateOperationsInput | string
    water?: AcquaUpdateOneWithoutDeviceNestedInput
    aria?: AriaUpdateOneWithoutDeviceNestedInput
  }

  export type DispositivoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    connectionString?: StringFieldUpdateOperationsInput | string
    matricola?: StringFieldUpdateOperationsInput | string
    water?: AcquaUncheckedUpdateOneWithoutDeviceNestedInput
    aria?: AriaUncheckedUpdateOneWithoutDeviceNestedInput
  }

  export type DispositivoCreateManyInput = {
    connectionString: string
    matricola: string
  }

  export type DispositivoUpdateManyMutationInput = {
    connectionString?: StringFieldUpdateOperationsInput | string
    matricola?: StringFieldUpdateOperationsInput | string
  }

  export type DispositivoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    connectionString?: StringFieldUpdateOperationsInput | string
    matricola?: StringFieldUpdateOperationsInput | string
  }

  export type AcquaCreateInput = {
    device: DispositivoCreateNestedOneWithoutWaterInput
    misurazioniAcqua?: MisurazioniAcquaCreateNestedManyWithoutDispositivoInput
  }

  export type AcquaUncheckedCreateInput = {
    idDispositivo: number
    misurazioniAcqua?: MisurazioniAcquaUncheckedCreateNestedManyWithoutDispositivoInput
  }

  export type AcquaUpdateInput = {
    device?: DispositivoUpdateOneRequiredWithoutWaterNestedInput
    misurazioniAcqua?: MisurazioniAcquaUpdateManyWithoutDispositivoNestedInput
  }

  export type AcquaUncheckedUpdateInput = {
    idDispositivo?: IntFieldUpdateOperationsInput | number
    misurazioniAcqua?: MisurazioniAcquaUncheckedUpdateManyWithoutDispositivoNestedInput
  }

  export type AcquaCreateManyInput = {
    idDispositivo: number
  }

  export type AcquaUpdateManyMutationInput = {

  }

  export type AcquaUncheckedUpdateManyInput = {
    idDispositivo?: IntFieldUpdateOperationsInput | number
  }

  export type MisurazioniAcquaCreateInput = {
    pH: number
    metalli: number
    data?: Date | string
    dispositivo: AcquaCreateNestedOneWithoutMisurazioniAcquaInput
  }

  export type MisurazioniAcquaUncheckedCreateInput = {
    id?: number
    pH: number
    metalli: number
    data?: Date | string
    dispId: number
  }

  export type MisurazioniAcquaUpdateInput = {
    pH?: FloatFieldUpdateOperationsInput | number
    metalli?: FloatFieldUpdateOperationsInput | number
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    dispositivo?: AcquaUpdateOneRequiredWithoutMisurazioniAcquaNestedInput
  }

  export type MisurazioniAcquaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pH?: FloatFieldUpdateOperationsInput | number
    metalli?: FloatFieldUpdateOperationsInput | number
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    dispId?: IntFieldUpdateOperationsInput | number
  }

  export type MisurazioniAcquaCreateManyInput = {
    pH: number
    metalli: number
    data?: Date | string
    dispId: number
  }

  export type MisurazioniAcquaUpdateManyMutationInput = {
    pH?: FloatFieldUpdateOperationsInput | number
    metalli?: FloatFieldUpdateOperationsInput | number
    data?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MisurazioniAcquaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pH?: FloatFieldUpdateOperationsInput | number
    metalli?: FloatFieldUpdateOperationsInput | number
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    dispId?: IntFieldUpdateOperationsInput | number
  }

  export type AriaCreateInput = {
    device: DispositivoCreateNestedOneWithoutAriaInput
    misurazioneAria?: MisurazioniAriaCreateNestedManyWithoutDispositivoInput
  }

  export type AriaUncheckedCreateInput = {
    idDispositivo: number
    misurazioneAria?: MisurazioniAriaUncheckedCreateNestedManyWithoutDispositivoInput
  }

  export type AriaUpdateInput = {
    device?: DispositivoUpdateOneRequiredWithoutAriaNestedInput
    misurazioneAria?: MisurazioniAriaUpdateManyWithoutDispositivoNestedInput
  }

  export type AriaUncheckedUpdateInput = {
    idDispositivo?: IntFieldUpdateOperationsInput | number
    misurazioneAria?: MisurazioniAriaUncheckedUpdateManyWithoutDispositivoNestedInput
  }

  export type AriaCreateManyInput = {
    idDispositivo: number
  }

  export type AriaUpdateManyMutationInput = {

  }

  export type AriaUncheckedUpdateManyInput = {
    idDispositivo?: IntFieldUpdateOperationsInput | number
  }

  export type MisurazioniAriaCreateInput = {
    cov: number
    gas: number
    data?: Date | string
    dispositivo: AriaCreateNestedOneWithoutMisurazioneAriaInput
  }

  export type MisurazioniAriaUncheckedCreateInput = {
    id?: number
    cov: number
    gas: number
    data?: Date | string
    dispId: number
  }

  export type MisurazioniAriaUpdateInput = {
    cov?: FloatFieldUpdateOperationsInput | number
    gas?: FloatFieldUpdateOperationsInput | number
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    dispositivo?: AriaUpdateOneRequiredWithoutMisurazioneAriaNestedInput
  }

  export type MisurazioniAriaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cov?: FloatFieldUpdateOperationsInput | number
    gas?: FloatFieldUpdateOperationsInput | number
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    dispId?: IntFieldUpdateOperationsInput | number
  }

  export type MisurazioniAriaCreateManyInput = {
    cov: number
    gas: number
    data?: Date | string
    dispId: number
  }

  export type MisurazioniAriaUpdateManyMutationInput = {
    cov?: FloatFieldUpdateOperationsInput | number
    gas?: FloatFieldUpdateOperationsInput | number
    data?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MisurazioniAriaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cov?: FloatFieldUpdateOperationsInput | number
    gas?: FloatFieldUpdateOperationsInput | number
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    dispId?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type AcquaNullableRelationFilter = {
    is?: AcquaWhereInput | null
    isNot?: AcquaWhereInput | null
  }

  export type AriaNullableRelationFilter = {
    is?: AriaWhereInput | null
    isNot?: AriaWhereInput | null
  }

  export type DispositivoCountOrderByAggregateInput = {
    id?: SortOrder
    connectionString?: SortOrder
    matricola?: SortOrder
  }

  export type DispositivoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DispositivoMaxOrderByAggregateInput = {
    id?: SortOrder
    connectionString?: SortOrder
    matricola?: SortOrder
  }

  export type DispositivoMinOrderByAggregateInput = {
    id?: SortOrder
    connectionString?: SortOrder
    matricola?: SortOrder
  }

  export type DispositivoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DispositivoRelationFilter = {
    is?: DispositivoWhereInput
    isNot?: DispositivoWhereInput
  }

  export type MisurazioniAcquaListRelationFilter = {
    every?: MisurazioniAcquaWhereInput
    some?: MisurazioniAcquaWhereInput
    none?: MisurazioniAcquaWhereInput
  }

  export type MisurazioniAcquaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AcquaCountOrderByAggregateInput = {
    idDispositivo?: SortOrder
  }

  export type AcquaAvgOrderByAggregateInput = {
    idDispositivo?: SortOrder
  }

  export type AcquaMaxOrderByAggregateInput = {
    idDispositivo?: SortOrder
  }

  export type AcquaMinOrderByAggregateInput = {
    idDispositivo?: SortOrder
  }

  export type AcquaSumOrderByAggregateInput = {
    idDispositivo?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AcquaRelationFilter = {
    is?: AcquaWhereInput
    isNot?: AcquaWhereInput
  }

  export type MisurazioniAcquaCountOrderByAggregateInput = {
    id?: SortOrder
    pH?: SortOrder
    metalli?: SortOrder
    data?: SortOrder
    dispId?: SortOrder
  }

  export type MisurazioniAcquaAvgOrderByAggregateInput = {
    id?: SortOrder
    pH?: SortOrder
    metalli?: SortOrder
    dispId?: SortOrder
  }

  export type MisurazioniAcquaMaxOrderByAggregateInput = {
    id?: SortOrder
    pH?: SortOrder
    metalli?: SortOrder
    data?: SortOrder
    dispId?: SortOrder
  }

  export type MisurazioniAcquaMinOrderByAggregateInput = {
    id?: SortOrder
    pH?: SortOrder
    metalli?: SortOrder
    data?: SortOrder
    dispId?: SortOrder
  }

  export type MisurazioniAcquaSumOrderByAggregateInput = {
    id?: SortOrder
    pH?: SortOrder
    metalli?: SortOrder
    dispId?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type MisurazioniAriaListRelationFilter = {
    every?: MisurazioniAriaWhereInput
    some?: MisurazioniAriaWhereInput
    none?: MisurazioniAriaWhereInput
  }

  export type MisurazioniAriaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AriaCountOrderByAggregateInput = {
    idDispositivo?: SortOrder
  }

  export type AriaAvgOrderByAggregateInput = {
    idDispositivo?: SortOrder
  }

  export type AriaMaxOrderByAggregateInput = {
    idDispositivo?: SortOrder
  }

  export type AriaMinOrderByAggregateInput = {
    idDispositivo?: SortOrder
  }

  export type AriaSumOrderByAggregateInput = {
    idDispositivo?: SortOrder
  }

  export type AriaRelationFilter = {
    is?: AriaWhereInput
    isNot?: AriaWhereInput
  }

  export type MisurazioniAriaCountOrderByAggregateInput = {
    id?: SortOrder
    cov?: SortOrder
    gas?: SortOrder
    data?: SortOrder
    dispId?: SortOrder
  }

  export type MisurazioniAriaAvgOrderByAggregateInput = {
    id?: SortOrder
    cov?: SortOrder
    gas?: SortOrder
    dispId?: SortOrder
  }

  export type MisurazioniAriaMaxOrderByAggregateInput = {
    id?: SortOrder
    cov?: SortOrder
    gas?: SortOrder
    data?: SortOrder
    dispId?: SortOrder
  }

  export type MisurazioniAriaMinOrderByAggregateInput = {
    id?: SortOrder
    cov?: SortOrder
    gas?: SortOrder
    data?: SortOrder
    dispId?: SortOrder
  }

  export type MisurazioniAriaSumOrderByAggregateInput = {
    id?: SortOrder
    cov?: SortOrder
    gas?: SortOrder
    dispId?: SortOrder
  }

  export type AcquaCreateNestedOneWithoutDeviceInput = {
    create?: XOR<AcquaCreateWithoutDeviceInput, AcquaUncheckedCreateWithoutDeviceInput>
    connectOrCreate?: AcquaCreateOrConnectWithoutDeviceInput
    connect?: AcquaWhereUniqueInput
  }

  export type AriaCreateNestedOneWithoutDeviceInput = {
    create?: XOR<AriaCreateWithoutDeviceInput, AriaUncheckedCreateWithoutDeviceInput>
    connectOrCreate?: AriaCreateOrConnectWithoutDeviceInput
    connect?: AriaWhereUniqueInput
  }

  export type AcquaUncheckedCreateNestedOneWithoutDeviceInput = {
    create?: XOR<AcquaCreateWithoutDeviceInput, AcquaUncheckedCreateWithoutDeviceInput>
    connectOrCreate?: AcquaCreateOrConnectWithoutDeviceInput
    connect?: AcquaWhereUniqueInput
  }

  export type AriaUncheckedCreateNestedOneWithoutDeviceInput = {
    create?: XOR<AriaCreateWithoutDeviceInput, AriaUncheckedCreateWithoutDeviceInput>
    connectOrCreate?: AriaCreateOrConnectWithoutDeviceInput
    connect?: AriaWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type AcquaUpdateOneWithoutDeviceNestedInput = {
    create?: XOR<AcquaCreateWithoutDeviceInput, AcquaUncheckedCreateWithoutDeviceInput>
    connectOrCreate?: AcquaCreateOrConnectWithoutDeviceInput
    upsert?: AcquaUpsertWithoutDeviceInput
    disconnect?: AcquaWhereInput | boolean
    delete?: AcquaWhereInput | boolean
    connect?: AcquaWhereUniqueInput
    update?: XOR<XOR<AcquaUpdateToOneWithWhereWithoutDeviceInput, AcquaUpdateWithoutDeviceInput>, AcquaUncheckedUpdateWithoutDeviceInput>
  }

  export type AriaUpdateOneWithoutDeviceNestedInput = {
    create?: XOR<AriaCreateWithoutDeviceInput, AriaUncheckedCreateWithoutDeviceInput>
    connectOrCreate?: AriaCreateOrConnectWithoutDeviceInput
    upsert?: AriaUpsertWithoutDeviceInput
    disconnect?: AriaWhereInput | boolean
    delete?: AriaWhereInput | boolean
    connect?: AriaWhereUniqueInput
    update?: XOR<XOR<AriaUpdateToOneWithWhereWithoutDeviceInput, AriaUpdateWithoutDeviceInput>, AriaUncheckedUpdateWithoutDeviceInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AcquaUncheckedUpdateOneWithoutDeviceNestedInput = {
    create?: XOR<AcquaCreateWithoutDeviceInput, AcquaUncheckedCreateWithoutDeviceInput>
    connectOrCreate?: AcquaCreateOrConnectWithoutDeviceInput
    upsert?: AcquaUpsertWithoutDeviceInput
    disconnect?: AcquaWhereInput | boolean
    delete?: AcquaWhereInput | boolean
    connect?: AcquaWhereUniqueInput
    update?: XOR<XOR<AcquaUpdateToOneWithWhereWithoutDeviceInput, AcquaUpdateWithoutDeviceInput>, AcquaUncheckedUpdateWithoutDeviceInput>
  }

  export type AriaUncheckedUpdateOneWithoutDeviceNestedInput = {
    create?: XOR<AriaCreateWithoutDeviceInput, AriaUncheckedCreateWithoutDeviceInput>
    connectOrCreate?: AriaCreateOrConnectWithoutDeviceInput
    upsert?: AriaUpsertWithoutDeviceInput
    disconnect?: AriaWhereInput | boolean
    delete?: AriaWhereInput | boolean
    connect?: AriaWhereUniqueInput
    update?: XOR<XOR<AriaUpdateToOneWithWhereWithoutDeviceInput, AriaUpdateWithoutDeviceInput>, AriaUncheckedUpdateWithoutDeviceInput>
  }

  export type DispositivoCreateNestedOneWithoutWaterInput = {
    create?: XOR<DispositivoCreateWithoutWaterInput, DispositivoUncheckedCreateWithoutWaterInput>
    connectOrCreate?: DispositivoCreateOrConnectWithoutWaterInput
    connect?: DispositivoWhereUniqueInput
  }

  export type MisurazioniAcquaCreateNestedManyWithoutDispositivoInput = {
    create?: XOR<MisurazioniAcquaCreateWithoutDispositivoInput, MisurazioniAcquaUncheckedCreateWithoutDispositivoInput> | MisurazioniAcquaCreateWithoutDispositivoInput[] | MisurazioniAcquaUncheckedCreateWithoutDispositivoInput[]
    connectOrCreate?: MisurazioniAcquaCreateOrConnectWithoutDispositivoInput | MisurazioniAcquaCreateOrConnectWithoutDispositivoInput[]
    createMany?: MisurazioniAcquaCreateManyDispositivoInputEnvelope
    connect?: MisurazioniAcquaWhereUniqueInput | MisurazioniAcquaWhereUniqueInput[]
  }

  export type MisurazioniAcquaUncheckedCreateNestedManyWithoutDispositivoInput = {
    create?: XOR<MisurazioniAcquaCreateWithoutDispositivoInput, MisurazioniAcquaUncheckedCreateWithoutDispositivoInput> | MisurazioniAcquaCreateWithoutDispositivoInput[] | MisurazioniAcquaUncheckedCreateWithoutDispositivoInput[]
    connectOrCreate?: MisurazioniAcquaCreateOrConnectWithoutDispositivoInput | MisurazioniAcquaCreateOrConnectWithoutDispositivoInput[]
    createMany?: MisurazioniAcquaCreateManyDispositivoInputEnvelope
    connect?: MisurazioniAcquaWhereUniqueInput | MisurazioniAcquaWhereUniqueInput[]
  }

  export type DispositivoUpdateOneRequiredWithoutWaterNestedInput = {
    create?: XOR<DispositivoCreateWithoutWaterInput, DispositivoUncheckedCreateWithoutWaterInput>
    connectOrCreate?: DispositivoCreateOrConnectWithoutWaterInput
    upsert?: DispositivoUpsertWithoutWaterInput
    connect?: DispositivoWhereUniqueInput
    update?: XOR<XOR<DispositivoUpdateToOneWithWhereWithoutWaterInput, DispositivoUpdateWithoutWaterInput>, DispositivoUncheckedUpdateWithoutWaterInput>
  }

  export type MisurazioniAcquaUpdateManyWithoutDispositivoNestedInput = {
    create?: XOR<MisurazioniAcquaCreateWithoutDispositivoInput, MisurazioniAcquaUncheckedCreateWithoutDispositivoInput> | MisurazioniAcquaCreateWithoutDispositivoInput[] | MisurazioniAcquaUncheckedCreateWithoutDispositivoInput[]
    connectOrCreate?: MisurazioniAcquaCreateOrConnectWithoutDispositivoInput | MisurazioniAcquaCreateOrConnectWithoutDispositivoInput[]
    upsert?: MisurazioniAcquaUpsertWithWhereUniqueWithoutDispositivoInput | MisurazioniAcquaUpsertWithWhereUniqueWithoutDispositivoInput[]
    createMany?: MisurazioniAcquaCreateManyDispositivoInputEnvelope
    set?: MisurazioniAcquaWhereUniqueInput | MisurazioniAcquaWhereUniqueInput[]
    disconnect?: MisurazioniAcquaWhereUniqueInput | MisurazioniAcquaWhereUniqueInput[]
    delete?: MisurazioniAcquaWhereUniqueInput | MisurazioniAcquaWhereUniqueInput[]
    connect?: MisurazioniAcquaWhereUniqueInput | MisurazioniAcquaWhereUniqueInput[]
    update?: MisurazioniAcquaUpdateWithWhereUniqueWithoutDispositivoInput | MisurazioniAcquaUpdateWithWhereUniqueWithoutDispositivoInput[]
    updateMany?: MisurazioniAcquaUpdateManyWithWhereWithoutDispositivoInput | MisurazioniAcquaUpdateManyWithWhereWithoutDispositivoInput[]
    deleteMany?: MisurazioniAcquaScalarWhereInput | MisurazioniAcquaScalarWhereInput[]
  }

  export type MisurazioniAcquaUncheckedUpdateManyWithoutDispositivoNestedInput = {
    create?: XOR<MisurazioniAcquaCreateWithoutDispositivoInput, MisurazioniAcquaUncheckedCreateWithoutDispositivoInput> | MisurazioniAcquaCreateWithoutDispositivoInput[] | MisurazioniAcquaUncheckedCreateWithoutDispositivoInput[]
    connectOrCreate?: MisurazioniAcquaCreateOrConnectWithoutDispositivoInput | MisurazioniAcquaCreateOrConnectWithoutDispositivoInput[]
    upsert?: MisurazioniAcquaUpsertWithWhereUniqueWithoutDispositivoInput | MisurazioniAcquaUpsertWithWhereUniqueWithoutDispositivoInput[]
    createMany?: MisurazioniAcquaCreateManyDispositivoInputEnvelope
    set?: MisurazioniAcquaWhereUniqueInput | MisurazioniAcquaWhereUniqueInput[]
    disconnect?: MisurazioniAcquaWhereUniqueInput | MisurazioniAcquaWhereUniqueInput[]
    delete?: MisurazioniAcquaWhereUniqueInput | MisurazioniAcquaWhereUniqueInput[]
    connect?: MisurazioniAcquaWhereUniqueInput | MisurazioniAcquaWhereUniqueInput[]
    update?: MisurazioniAcquaUpdateWithWhereUniqueWithoutDispositivoInput | MisurazioniAcquaUpdateWithWhereUniqueWithoutDispositivoInput[]
    updateMany?: MisurazioniAcquaUpdateManyWithWhereWithoutDispositivoInput | MisurazioniAcquaUpdateManyWithWhereWithoutDispositivoInput[]
    deleteMany?: MisurazioniAcquaScalarWhereInput | MisurazioniAcquaScalarWhereInput[]
  }

  export type AcquaCreateNestedOneWithoutMisurazioniAcquaInput = {
    create?: XOR<AcquaCreateWithoutMisurazioniAcquaInput, AcquaUncheckedCreateWithoutMisurazioniAcquaInput>
    connectOrCreate?: AcquaCreateOrConnectWithoutMisurazioniAcquaInput
    connect?: AcquaWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AcquaUpdateOneRequiredWithoutMisurazioniAcquaNestedInput = {
    create?: XOR<AcquaCreateWithoutMisurazioniAcquaInput, AcquaUncheckedCreateWithoutMisurazioniAcquaInput>
    connectOrCreate?: AcquaCreateOrConnectWithoutMisurazioniAcquaInput
    upsert?: AcquaUpsertWithoutMisurazioniAcquaInput
    connect?: AcquaWhereUniqueInput
    update?: XOR<XOR<AcquaUpdateToOneWithWhereWithoutMisurazioniAcquaInput, AcquaUpdateWithoutMisurazioniAcquaInput>, AcquaUncheckedUpdateWithoutMisurazioniAcquaInput>
  }

  export type DispositivoCreateNestedOneWithoutAriaInput = {
    create?: XOR<DispositivoCreateWithoutAriaInput, DispositivoUncheckedCreateWithoutAriaInput>
    connectOrCreate?: DispositivoCreateOrConnectWithoutAriaInput
    connect?: DispositivoWhereUniqueInput
  }

  export type MisurazioniAriaCreateNestedManyWithoutDispositivoInput = {
    create?: XOR<MisurazioniAriaCreateWithoutDispositivoInput, MisurazioniAriaUncheckedCreateWithoutDispositivoInput> | MisurazioniAriaCreateWithoutDispositivoInput[] | MisurazioniAriaUncheckedCreateWithoutDispositivoInput[]
    connectOrCreate?: MisurazioniAriaCreateOrConnectWithoutDispositivoInput | MisurazioniAriaCreateOrConnectWithoutDispositivoInput[]
    createMany?: MisurazioniAriaCreateManyDispositivoInputEnvelope
    connect?: MisurazioniAriaWhereUniqueInput | MisurazioniAriaWhereUniqueInput[]
  }

  export type MisurazioniAriaUncheckedCreateNestedManyWithoutDispositivoInput = {
    create?: XOR<MisurazioniAriaCreateWithoutDispositivoInput, MisurazioniAriaUncheckedCreateWithoutDispositivoInput> | MisurazioniAriaCreateWithoutDispositivoInput[] | MisurazioniAriaUncheckedCreateWithoutDispositivoInput[]
    connectOrCreate?: MisurazioniAriaCreateOrConnectWithoutDispositivoInput | MisurazioniAriaCreateOrConnectWithoutDispositivoInput[]
    createMany?: MisurazioniAriaCreateManyDispositivoInputEnvelope
    connect?: MisurazioniAriaWhereUniqueInput | MisurazioniAriaWhereUniqueInput[]
  }

  export type DispositivoUpdateOneRequiredWithoutAriaNestedInput = {
    create?: XOR<DispositivoCreateWithoutAriaInput, DispositivoUncheckedCreateWithoutAriaInput>
    connectOrCreate?: DispositivoCreateOrConnectWithoutAriaInput
    upsert?: DispositivoUpsertWithoutAriaInput
    connect?: DispositivoWhereUniqueInput
    update?: XOR<XOR<DispositivoUpdateToOneWithWhereWithoutAriaInput, DispositivoUpdateWithoutAriaInput>, DispositivoUncheckedUpdateWithoutAriaInput>
  }

  export type MisurazioniAriaUpdateManyWithoutDispositivoNestedInput = {
    create?: XOR<MisurazioniAriaCreateWithoutDispositivoInput, MisurazioniAriaUncheckedCreateWithoutDispositivoInput> | MisurazioniAriaCreateWithoutDispositivoInput[] | MisurazioniAriaUncheckedCreateWithoutDispositivoInput[]
    connectOrCreate?: MisurazioniAriaCreateOrConnectWithoutDispositivoInput | MisurazioniAriaCreateOrConnectWithoutDispositivoInput[]
    upsert?: MisurazioniAriaUpsertWithWhereUniqueWithoutDispositivoInput | MisurazioniAriaUpsertWithWhereUniqueWithoutDispositivoInput[]
    createMany?: MisurazioniAriaCreateManyDispositivoInputEnvelope
    set?: MisurazioniAriaWhereUniqueInput | MisurazioniAriaWhereUniqueInput[]
    disconnect?: MisurazioniAriaWhereUniqueInput | MisurazioniAriaWhereUniqueInput[]
    delete?: MisurazioniAriaWhereUniqueInput | MisurazioniAriaWhereUniqueInput[]
    connect?: MisurazioniAriaWhereUniqueInput | MisurazioniAriaWhereUniqueInput[]
    update?: MisurazioniAriaUpdateWithWhereUniqueWithoutDispositivoInput | MisurazioniAriaUpdateWithWhereUniqueWithoutDispositivoInput[]
    updateMany?: MisurazioniAriaUpdateManyWithWhereWithoutDispositivoInput | MisurazioniAriaUpdateManyWithWhereWithoutDispositivoInput[]
    deleteMany?: MisurazioniAriaScalarWhereInput | MisurazioniAriaScalarWhereInput[]
  }

  export type MisurazioniAriaUncheckedUpdateManyWithoutDispositivoNestedInput = {
    create?: XOR<MisurazioniAriaCreateWithoutDispositivoInput, MisurazioniAriaUncheckedCreateWithoutDispositivoInput> | MisurazioniAriaCreateWithoutDispositivoInput[] | MisurazioniAriaUncheckedCreateWithoutDispositivoInput[]
    connectOrCreate?: MisurazioniAriaCreateOrConnectWithoutDispositivoInput | MisurazioniAriaCreateOrConnectWithoutDispositivoInput[]
    upsert?: MisurazioniAriaUpsertWithWhereUniqueWithoutDispositivoInput | MisurazioniAriaUpsertWithWhereUniqueWithoutDispositivoInput[]
    createMany?: MisurazioniAriaCreateManyDispositivoInputEnvelope
    set?: MisurazioniAriaWhereUniqueInput | MisurazioniAriaWhereUniqueInput[]
    disconnect?: MisurazioniAriaWhereUniqueInput | MisurazioniAriaWhereUniqueInput[]
    delete?: MisurazioniAriaWhereUniqueInput | MisurazioniAriaWhereUniqueInput[]
    connect?: MisurazioniAriaWhereUniqueInput | MisurazioniAriaWhereUniqueInput[]
    update?: MisurazioniAriaUpdateWithWhereUniqueWithoutDispositivoInput | MisurazioniAriaUpdateWithWhereUniqueWithoutDispositivoInput[]
    updateMany?: MisurazioniAriaUpdateManyWithWhereWithoutDispositivoInput | MisurazioniAriaUpdateManyWithWhereWithoutDispositivoInput[]
    deleteMany?: MisurazioniAriaScalarWhereInput | MisurazioniAriaScalarWhereInput[]
  }

  export type AriaCreateNestedOneWithoutMisurazioneAriaInput = {
    create?: XOR<AriaCreateWithoutMisurazioneAriaInput, AriaUncheckedCreateWithoutMisurazioneAriaInput>
    connectOrCreate?: AriaCreateOrConnectWithoutMisurazioneAriaInput
    connect?: AriaWhereUniqueInput
  }

  export type AriaUpdateOneRequiredWithoutMisurazioneAriaNestedInput = {
    create?: XOR<AriaCreateWithoutMisurazioneAriaInput, AriaUncheckedCreateWithoutMisurazioneAriaInput>
    connectOrCreate?: AriaCreateOrConnectWithoutMisurazioneAriaInput
    upsert?: AriaUpsertWithoutMisurazioneAriaInput
    connect?: AriaWhereUniqueInput
    update?: XOR<XOR<AriaUpdateToOneWithWhereWithoutMisurazioneAriaInput, AriaUpdateWithoutMisurazioneAriaInput>, AriaUncheckedUpdateWithoutMisurazioneAriaInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type AcquaCreateWithoutDeviceInput = {
    misurazioniAcqua?: MisurazioniAcquaCreateNestedManyWithoutDispositivoInput
  }

  export type AcquaUncheckedCreateWithoutDeviceInput = {
    misurazioniAcqua?: MisurazioniAcquaUncheckedCreateNestedManyWithoutDispositivoInput
  }

  export type AcquaCreateOrConnectWithoutDeviceInput = {
    where: AcquaWhereUniqueInput
    create: XOR<AcquaCreateWithoutDeviceInput, AcquaUncheckedCreateWithoutDeviceInput>
  }

  export type AriaCreateWithoutDeviceInput = {
    misurazioneAria?: MisurazioniAriaCreateNestedManyWithoutDispositivoInput
  }

  export type AriaUncheckedCreateWithoutDeviceInput = {
    misurazioneAria?: MisurazioniAriaUncheckedCreateNestedManyWithoutDispositivoInput
  }

  export type AriaCreateOrConnectWithoutDeviceInput = {
    where: AriaWhereUniqueInput
    create: XOR<AriaCreateWithoutDeviceInput, AriaUncheckedCreateWithoutDeviceInput>
  }

  export type AcquaUpsertWithoutDeviceInput = {
    update: XOR<AcquaUpdateWithoutDeviceInput, AcquaUncheckedUpdateWithoutDeviceInput>
    create: XOR<AcquaCreateWithoutDeviceInput, AcquaUncheckedCreateWithoutDeviceInput>
    where?: AcquaWhereInput
  }

  export type AcquaUpdateToOneWithWhereWithoutDeviceInput = {
    where?: AcquaWhereInput
    data: XOR<AcquaUpdateWithoutDeviceInput, AcquaUncheckedUpdateWithoutDeviceInput>
  }

  export type AcquaUpdateWithoutDeviceInput = {
    misurazioniAcqua?: MisurazioniAcquaUpdateManyWithoutDispositivoNestedInput
  }

  export type AcquaUncheckedUpdateWithoutDeviceInput = {
    misurazioniAcqua?: MisurazioniAcquaUncheckedUpdateManyWithoutDispositivoNestedInput
  }

  export type AriaUpsertWithoutDeviceInput = {
    update: XOR<AriaUpdateWithoutDeviceInput, AriaUncheckedUpdateWithoutDeviceInput>
    create: XOR<AriaCreateWithoutDeviceInput, AriaUncheckedCreateWithoutDeviceInput>
    where?: AriaWhereInput
  }

  export type AriaUpdateToOneWithWhereWithoutDeviceInput = {
    where?: AriaWhereInput
    data: XOR<AriaUpdateWithoutDeviceInput, AriaUncheckedUpdateWithoutDeviceInput>
  }

  export type AriaUpdateWithoutDeviceInput = {
    misurazioneAria?: MisurazioniAriaUpdateManyWithoutDispositivoNestedInput
  }

  export type AriaUncheckedUpdateWithoutDeviceInput = {
    misurazioneAria?: MisurazioniAriaUncheckedUpdateManyWithoutDispositivoNestedInput
  }

  export type DispositivoCreateWithoutWaterInput = {
    connectionString: string
    matricola: string
    aria?: AriaCreateNestedOneWithoutDeviceInput
  }

  export type DispositivoUncheckedCreateWithoutWaterInput = {
    id?: number
    connectionString: string
    matricola: string
    aria?: AriaUncheckedCreateNestedOneWithoutDeviceInput
  }

  export type DispositivoCreateOrConnectWithoutWaterInput = {
    where: DispositivoWhereUniqueInput
    create: XOR<DispositivoCreateWithoutWaterInput, DispositivoUncheckedCreateWithoutWaterInput>
  }

  export type MisurazioniAcquaCreateWithoutDispositivoInput = {
    pH: number
    metalli: number
    data?: Date | string
  }

  export type MisurazioniAcquaUncheckedCreateWithoutDispositivoInput = {
    id?: number
    pH: number
    metalli: number
    data?: Date | string
  }

  export type MisurazioniAcquaCreateOrConnectWithoutDispositivoInput = {
    where: MisurazioniAcquaWhereUniqueInput
    create: XOR<MisurazioniAcquaCreateWithoutDispositivoInput, MisurazioniAcquaUncheckedCreateWithoutDispositivoInput>
  }

  export type MisurazioniAcquaCreateManyDispositivoInputEnvelope = {
    data: MisurazioniAcquaCreateManyDispositivoInput | MisurazioniAcquaCreateManyDispositivoInput[]
  }

  export type DispositivoUpsertWithoutWaterInput = {
    update: XOR<DispositivoUpdateWithoutWaterInput, DispositivoUncheckedUpdateWithoutWaterInput>
    create: XOR<DispositivoCreateWithoutWaterInput, DispositivoUncheckedCreateWithoutWaterInput>
    where?: DispositivoWhereInput
  }

  export type DispositivoUpdateToOneWithWhereWithoutWaterInput = {
    where?: DispositivoWhereInput
    data: XOR<DispositivoUpdateWithoutWaterInput, DispositivoUncheckedUpdateWithoutWaterInput>
  }

  export type DispositivoUpdateWithoutWaterInput = {
    connectionString?: StringFieldUpdateOperationsInput | string
    matricola?: StringFieldUpdateOperationsInput | string
    aria?: AriaUpdateOneWithoutDeviceNestedInput
  }

  export type DispositivoUncheckedUpdateWithoutWaterInput = {
    id?: IntFieldUpdateOperationsInput | number
    connectionString?: StringFieldUpdateOperationsInput | string
    matricola?: StringFieldUpdateOperationsInput | string
    aria?: AriaUncheckedUpdateOneWithoutDeviceNestedInput
  }

  export type MisurazioniAcquaUpsertWithWhereUniqueWithoutDispositivoInput = {
    where: MisurazioniAcquaWhereUniqueInput
    update: XOR<MisurazioniAcquaUpdateWithoutDispositivoInput, MisurazioniAcquaUncheckedUpdateWithoutDispositivoInput>
    create: XOR<MisurazioniAcquaCreateWithoutDispositivoInput, MisurazioniAcquaUncheckedCreateWithoutDispositivoInput>
  }

  export type MisurazioniAcquaUpdateWithWhereUniqueWithoutDispositivoInput = {
    where: MisurazioniAcquaWhereUniqueInput
    data: XOR<MisurazioniAcquaUpdateWithoutDispositivoInput, MisurazioniAcquaUncheckedUpdateWithoutDispositivoInput>
  }

  export type MisurazioniAcquaUpdateManyWithWhereWithoutDispositivoInput = {
    where: MisurazioniAcquaScalarWhereInput
    data: XOR<MisurazioniAcquaUpdateManyMutationInput, MisurazioniAcquaUncheckedUpdateManyWithoutDispositivoInput>
  }

  export type MisurazioniAcquaScalarWhereInput = {
    AND?: MisurazioniAcquaScalarWhereInput | MisurazioniAcquaScalarWhereInput[]
    OR?: MisurazioniAcquaScalarWhereInput[]
    NOT?: MisurazioniAcquaScalarWhereInput | MisurazioniAcquaScalarWhereInput[]
    id?: IntFilter<"MisurazioniAcqua"> | number
    pH?: FloatFilter<"MisurazioniAcqua"> | number
    metalli?: FloatFilter<"MisurazioniAcqua"> | number
    data?: DateTimeFilter<"MisurazioniAcqua"> | Date | string
    dispId?: IntFilter<"MisurazioniAcqua"> | number
  }

  export type AcquaCreateWithoutMisurazioniAcquaInput = {
    device: DispositivoCreateNestedOneWithoutWaterInput
  }

  export type AcquaUncheckedCreateWithoutMisurazioniAcquaInput = {
    idDispositivo: number
  }

  export type AcquaCreateOrConnectWithoutMisurazioniAcquaInput = {
    where: AcquaWhereUniqueInput
    create: XOR<AcquaCreateWithoutMisurazioniAcquaInput, AcquaUncheckedCreateWithoutMisurazioniAcquaInput>
  }

  export type AcquaUpsertWithoutMisurazioniAcquaInput = {
    update: XOR<AcquaUpdateWithoutMisurazioniAcquaInput, AcquaUncheckedUpdateWithoutMisurazioniAcquaInput>
    create: XOR<AcquaCreateWithoutMisurazioniAcquaInput, AcquaUncheckedCreateWithoutMisurazioniAcquaInput>
    where?: AcquaWhereInput
  }

  export type AcquaUpdateToOneWithWhereWithoutMisurazioniAcquaInput = {
    where?: AcquaWhereInput
    data: XOR<AcquaUpdateWithoutMisurazioniAcquaInput, AcquaUncheckedUpdateWithoutMisurazioniAcquaInput>
  }

  export type AcquaUpdateWithoutMisurazioniAcquaInput = {
    device?: DispositivoUpdateOneRequiredWithoutWaterNestedInput
  }

  export type AcquaUncheckedUpdateWithoutMisurazioniAcquaInput = {
    idDispositivo?: IntFieldUpdateOperationsInput | number
  }

  export type DispositivoCreateWithoutAriaInput = {
    connectionString: string
    matricola: string
    water?: AcquaCreateNestedOneWithoutDeviceInput
  }

  export type DispositivoUncheckedCreateWithoutAriaInput = {
    id?: number
    connectionString: string
    matricola: string
    water?: AcquaUncheckedCreateNestedOneWithoutDeviceInput
  }

  export type DispositivoCreateOrConnectWithoutAriaInput = {
    where: DispositivoWhereUniqueInput
    create: XOR<DispositivoCreateWithoutAriaInput, DispositivoUncheckedCreateWithoutAriaInput>
  }

  export type MisurazioniAriaCreateWithoutDispositivoInput = {
    cov: number
    gas: number
    data?: Date | string
  }

  export type MisurazioniAriaUncheckedCreateWithoutDispositivoInput = {
    id?: number
    cov: number
    gas: number
    data?: Date | string
  }

  export type MisurazioniAriaCreateOrConnectWithoutDispositivoInput = {
    where: MisurazioniAriaWhereUniqueInput
    create: XOR<MisurazioniAriaCreateWithoutDispositivoInput, MisurazioniAriaUncheckedCreateWithoutDispositivoInput>
  }

  export type MisurazioniAriaCreateManyDispositivoInputEnvelope = {
    data: MisurazioniAriaCreateManyDispositivoInput | MisurazioniAriaCreateManyDispositivoInput[]
  }

  export type DispositivoUpsertWithoutAriaInput = {
    update: XOR<DispositivoUpdateWithoutAriaInput, DispositivoUncheckedUpdateWithoutAriaInput>
    create: XOR<DispositivoCreateWithoutAriaInput, DispositivoUncheckedCreateWithoutAriaInput>
    where?: DispositivoWhereInput
  }

  export type DispositivoUpdateToOneWithWhereWithoutAriaInput = {
    where?: DispositivoWhereInput
    data: XOR<DispositivoUpdateWithoutAriaInput, DispositivoUncheckedUpdateWithoutAriaInput>
  }

  export type DispositivoUpdateWithoutAriaInput = {
    connectionString?: StringFieldUpdateOperationsInput | string
    matricola?: StringFieldUpdateOperationsInput | string
    water?: AcquaUpdateOneWithoutDeviceNestedInput
  }

  export type DispositivoUncheckedUpdateWithoutAriaInput = {
    id?: IntFieldUpdateOperationsInput | number
    connectionString?: StringFieldUpdateOperationsInput | string
    matricola?: StringFieldUpdateOperationsInput | string
    water?: AcquaUncheckedUpdateOneWithoutDeviceNestedInput
  }

  export type MisurazioniAriaUpsertWithWhereUniqueWithoutDispositivoInput = {
    where: MisurazioniAriaWhereUniqueInput
    update: XOR<MisurazioniAriaUpdateWithoutDispositivoInput, MisurazioniAriaUncheckedUpdateWithoutDispositivoInput>
    create: XOR<MisurazioniAriaCreateWithoutDispositivoInput, MisurazioniAriaUncheckedCreateWithoutDispositivoInput>
  }

  export type MisurazioniAriaUpdateWithWhereUniqueWithoutDispositivoInput = {
    where: MisurazioniAriaWhereUniqueInput
    data: XOR<MisurazioniAriaUpdateWithoutDispositivoInput, MisurazioniAriaUncheckedUpdateWithoutDispositivoInput>
  }

  export type MisurazioniAriaUpdateManyWithWhereWithoutDispositivoInput = {
    where: MisurazioniAriaScalarWhereInput
    data: XOR<MisurazioniAriaUpdateManyMutationInput, MisurazioniAriaUncheckedUpdateManyWithoutDispositivoInput>
  }

  export type MisurazioniAriaScalarWhereInput = {
    AND?: MisurazioniAriaScalarWhereInput | MisurazioniAriaScalarWhereInput[]
    OR?: MisurazioniAriaScalarWhereInput[]
    NOT?: MisurazioniAriaScalarWhereInput | MisurazioniAriaScalarWhereInput[]
    id?: IntFilter<"MisurazioniAria"> | number
    cov?: FloatFilter<"MisurazioniAria"> | number
    gas?: FloatFilter<"MisurazioniAria"> | number
    data?: DateTimeFilter<"MisurazioniAria"> | Date | string
    dispId?: IntFilter<"MisurazioniAria"> | number
  }

  export type AriaCreateWithoutMisurazioneAriaInput = {
    device: DispositivoCreateNestedOneWithoutAriaInput
  }

  export type AriaUncheckedCreateWithoutMisurazioneAriaInput = {
    idDispositivo: number
  }

  export type AriaCreateOrConnectWithoutMisurazioneAriaInput = {
    where: AriaWhereUniqueInput
    create: XOR<AriaCreateWithoutMisurazioneAriaInput, AriaUncheckedCreateWithoutMisurazioneAriaInput>
  }

  export type AriaUpsertWithoutMisurazioneAriaInput = {
    update: XOR<AriaUpdateWithoutMisurazioneAriaInput, AriaUncheckedUpdateWithoutMisurazioneAriaInput>
    create: XOR<AriaCreateWithoutMisurazioneAriaInput, AriaUncheckedCreateWithoutMisurazioneAriaInput>
    where?: AriaWhereInput
  }

  export type AriaUpdateToOneWithWhereWithoutMisurazioneAriaInput = {
    where?: AriaWhereInput
    data: XOR<AriaUpdateWithoutMisurazioneAriaInput, AriaUncheckedUpdateWithoutMisurazioneAriaInput>
  }

  export type AriaUpdateWithoutMisurazioneAriaInput = {
    device?: DispositivoUpdateOneRequiredWithoutAriaNestedInput
  }

  export type AriaUncheckedUpdateWithoutMisurazioneAriaInput = {
    idDispositivo?: IntFieldUpdateOperationsInput | number
  }

  export type MisurazioniAcquaCreateManyDispositivoInput = {
    pH: number
    metalli: number
    data?: Date | string
  }

  export type MisurazioniAcquaUpdateWithoutDispositivoInput = {
    pH?: FloatFieldUpdateOperationsInput | number
    metalli?: FloatFieldUpdateOperationsInput | number
    data?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MisurazioniAcquaUncheckedUpdateWithoutDispositivoInput = {
    id?: IntFieldUpdateOperationsInput | number
    pH?: FloatFieldUpdateOperationsInput | number
    metalli?: FloatFieldUpdateOperationsInput | number
    data?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MisurazioniAcquaUncheckedUpdateManyWithoutDispositivoInput = {
    id?: IntFieldUpdateOperationsInput | number
    pH?: FloatFieldUpdateOperationsInput | number
    metalli?: FloatFieldUpdateOperationsInput | number
    data?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MisurazioniAriaCreateManyDispositivoInput = {
    cov: number
    gas: number
    data?: Date | string
  }

  export type MisurazioniAriaUpdateWithoutDispositivoInput = {
    cov?: FloatFieldUpdateOperationsInput | number
    gas?: FloatFieldUpdateOperationsInput | number
    data?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MisurazioniAriaUncheckedUpdateWithoutDispositivoInput = {
    id?: IntFieldUpdateOperationsInput | number
    cov?: FloatFieldUpdateOperationsInput | number
    gas?: FloatFieldUpdateOperationsInput | number
    data?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MisurazioniAriaUncheckedUpdateManyWithoutDispositivoInput = {
    id?: IntFieldUpdateOperationsInput | number
    cov?: FloatFieldUpdateOperationsInput | number
    gas?: FloatFieldUpdateOperationsInput | number
    data?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use AcquaCountOutputTypeDefaultArgs instead
     */
    export type AcquaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AcquaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AriaCountOutputTypeDefaultArgs instead
     */
    export type AriaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AriaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DispositivoDefaultArgs instead
     */
    export type DispositivoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DispositivoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AcquaDefaultArgs instead
     */
    export type AcquaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AcquaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MisurazioniAcquaDefaultArgs instead
     */
    export type MisurazioniAcquaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MisurazioniAcquaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AriaDefaultArgs instead
     */
    export type AriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AriaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MisurazioniAriaDefaultArgs instead
     */
    export type MisurazioniAriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MisurazioniAriaDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}